/*
* generated by Xtext
*/
package nl.dslmeinte.simscript.ui.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import nl.dslmeinte.simscript.structure.services.SimStructureDslGrammarAccess;

@Singleton
public class SimUiDslGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class UiModuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UiModule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUiModuleAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cUiModuleKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNotAuthenticatedAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cNotAuthenticatedNotAuthenticatedKeyword_2_0 = (Keyword)cNotAuthenticatedAssignment_2.eContents().get(0);
		private final Assignment cDefinitionsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDefinitionsTopLevelDefinitionParserRuleCall_3_0 = (RuleCall)cDefinitionsAssignment_3.eContents().get(0);
		
		/// **
		// * General Dependencies/Assumptions:
		// * 1.)	All widgets need framework js code (which should also be included in the HTML file) to work.
		// * / / *
		// * +------------+
		// * | structural |
		// * +------------+
		// * / UiModule:
		//	{UiModule} "ui-module" notAuthenticated?="not-authenticated"? definitions+=TopLevelDefinition*;
		public ParserRule getRule() { return rule; }

		//{UiModule} "ui-module" notAuthenticated?="not-authenticated"? definitions+=TopLevelDefinition*
		public Group getGroup() { return cGroup; }

		//{UiModule}
		public Action getUiModuleAction_0() { return cUiModuleAction_0; }

		//"ui-module"
		public Keyword getUiModuleKeyword_1() { return cUiModuleKeyword_1; }

		//notAuthenticated?="not-authenticated"?
		public Assignment getNotAuthenticatedAssignment_2() { return cNotAuthenticatedAssignment_2; }

		//"not-authenticated"
		public Keyword getNotAuthenticatedNotAuthenticatedKeyword_2_0() { return cNotAuthenticatedNotAuthenticatedKeyword_2_0; }

		//definitions+=TopLevelDefinition*
		public Assignment getDefinitionsAssignment_3() { return cDefinitionsAssignment_3; }

		//TopLevelDefinition
		public RuleCall getDefinitionsTopLevelDefinitionParserRuleCall_3_0() { return cDefinitionsTopLevelDefinitionParserRuleCall_3_0; }
	}

	public class TopLevelDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TopLevelDefinition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cViewableParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTableRowsDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cMethodDefinitionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// TODO  consider adding "module globals" such as (immutable) parameters and error handling
		/// *
		//	 * validation:
		//	 * 	the first screen of a module should not take any parameters, or the GotoModuleStatement should have arguments
		//	 * / TopLevelDefinition:
		//	Viewable | TableRowsDefinition | MethodDefinition;
		public ParserRule getRule() { return rule; }

		//Viewable | TableRowsDefinition | MethodDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//Viewable
		public RuleCall getViewableParserRuleCall_0() { return cViewableParserRuleCall_0; }

		//TableRowsDefinition
		public RuleCall getTableRowsDefinitionParserRuleCall_1() { return cTableRowsDefinitionParserRuleCall_1; }

		//MethodDefinition
		public RuleCall getMethodDefinitionParserRuleCall_2() { return cMethodDefinitionParserRuleCall_2; }
	}

	public class TableRowsDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TableRowsDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTableRowsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cParameterListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParameterListParameterListParserRuleCall_2_0 = (RuleCall)cParameterListAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRowsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRowsTableRowParserRuleCall_4_0 = (RuleCall)cRowsAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//TableRowsDefinition:
		//	"table-rows" name=ID parameterList=ParameterList "{" rows+=TableRow* "}";
		public ParserRule getRule() { return rule; }

		//"table-rows" name=ID parameterList=ParameterList "{" rows+=TableRow* "}"
		public Group getGroup() { return cGroup; }

		//"table-rows"
		public Keyword getTableRowsKeyword_0() { return cTableRowsKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//parameterList=ParameterList
		public Assignment getParameterListAssignment_2() { return cParameterListAssignment_2; }

		//ParameterList
		public RuleCall getParameterListParameterListParserRuleCall_2_0() { return cParameterListParameterListParserRuleCall_2_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//rows+=TableRow*
		public Assignment getRowsAssignment_4() { return cRowsAssignment_4; }

		//TableRow
		public RuleCall getRowsTableRowParserRuleCall_4_0() { return cRowsTableRowParserRuleCall_4_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class ViewableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Viewable");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDefinedViewableParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cManualViewableParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Viewable:
		//	DefinedViewable | ManualViewable;
		public ParserRule getRule() { return rule; }

		//DefinedViewable | ManualViewable
		public Alternatives getAlternatives() { return cAlternatives; }

		//DefinedViewable
		public RuleCall getDefinedViewableParserRuleCall_0() { return cDefinedViewableParserRuleCall_0; }

		//ManualViewable
		public RuleCall getManualViewableParserRuleCall_1() { return cManualViewableParserRuleCall_1; }
	}

	public class DefinedViewableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DefinedViewable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeViewableTypesEnumRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cParameterListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParameterListParameterListParserRuleCall_2_0 = (RuleCall)cParameterListAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cValuesBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cValuesBlockValuesBlockParserRuleCall_4_0 = (RuleCall)cValuesBlockAssignment_4.eContents().get(0);
		private final Assignment cDefinitionsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cDefinitionsLocalViewableDefinitionParserRuleCall_5_0 = (RuleCall)cDefinitionsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//// derived feature: =screen(Viewable it) ::= type == _screen_	[√]
		//// pulled-up features: type, name, parameterList
		//DefinedViewable:
		//	type=ViewableTypes name=ID parameterList=ParameterList "{" // (feature's value may be null)
		//	valuesBlock=ValuesBlock? // (feature's value is always non-null)
		//	definitions+=LocalViewableDefinition* "}";
		public ParserRule getRule() { return rule; }

		//type=ViewableTypes name=ID parameterList=ParameterList "{" // (feature's value may be null)
		//valuesBlock=ValuesBlock? // (feature's value is always non-null)
		//definitions+=LocalViewableDefinition* "}"
		public Group getGroup() { return cGroup; }

		//type=ViewableTypes
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }

		//ViewableTypes
		public RuleCall getTypeViewableTypesEnumRuleCall_0_0() { return cTypeViewableTypesEnumRuleCall_0_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//parameterList=ParameterList
		public Assignment getParameterListAssignment_2() { return cParameterListAssignment_2; }

		//ParameterList
		public RuleCall getParameterListParameterListParserRuleCall_2_0() { return cParameterListParameterListParserRuleCall_2_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//// (feature's value may be null)
		//valuesBlock=ValuesBlock?
		public Assignment getValuesBlockAssignment_4() { return cValuesBlockAssignment_4; }

		//ValuesBlock
		public RuleCall getValuesBlockValuesBlockParserRuleCall_4_0() { return cValuesBlockValuesBlockParserRuleCall_4_0; }

		//// (feature's value is always non-null)
		//definitions+=LocalViewableDefinition*
		public Assignment getDefinitionsAssignment_5() { return cDefinitionsAssignment_5; }

		//LocalViewableDefinition
		public RuleCall getDefinitionsLocalViewableDefinitionParserRuleCall_5_0() { return cDefinitionsLocalViewableDefinitionParserRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class ManualViewableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ManualViewable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cManualKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeViewableTypesEnumRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cParameterListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParameterListParameterListParserRuleCall_3_0 = (RuleCall)cParameterListAssignment_3.eContents().get(0);
		private final Keyword cInKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cNamespaceAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cNamespaceQualifiedNameParserRuleCall_5_0 = (RuleCall)cNamespaceAssignment_5.eContents().get(0);
		
		//// validation: warning in case of 0 elements					[√]
		//// derived feature: =screen(Viewable it) ::= type == _screen_	[√]
		/// *
		//	 * TODO  consider making a modal a separate viewable type
		//	 * The idea is that a modal should often be able to act as a confirm or an obligatory
		//	 * choice between a few actions in a way that's quite functional - e.g., persistent dialog box.
		//	 * / ManualViewable:
		//	"manual" type=ViewableTypes name=ID parameterList=ParameterList "in" namespace=QualifiedName;
		public ParserRule getRule() { return rule; }

		//"manual" type=ViewableTypes name=ID parameterList=ParameterList "in" namespace=QualifiedName
		public Group getGroup() { return cGroup; }

		//"manual"
		public Keyword getManualKeyword_0() { return cManualKeyword_0; }

		//type=ViewableTypes
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//ViewableTypes
		public RuleCall getTypeViewableTypesEnumRuleCall_1_0() { return cTypeViewableTypesEnumRuleCall_1_0; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//parameterList=ParameterList
		public Assignment getParameterListAssignment_3() { return cParameterListAssignment_3; }

		//ParameterList
		public RuleCall getParameterListParameterListParserRuleCall_3_0() { return cParameterListParameterListParserRuleCall_3_0; }

		//"in"
		public Keyword getInKeyword_4() { return cInKeyword_4; }

		//namespace=QualifiedName
		public Assignment getNamespaceAssignment_5() { return cNamespaceAssignment_5; }

		//QualifiedName
		public RuleCall getNamespaceQualifiedNameParserRuleCall_5_0() { return cNamespaceQualifiedNameParserRuleCall_5_0; }
	}

	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//	ID ("." ID)*;
		public ParserRule getRule() { return rule; }

		//ID ("." ID)*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//("." ID)*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}

	public class LocalViewableDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalViewableDefinition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cElementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMethodDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//LocalViewableDefinition:
		//	Element | MethodDefinition;
		public ParserRule getRule() { return rule; }

		//Element | MethodDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//Element
		public RuleCall getElementParserRuleCall_0() { return cElementParserRuleCall_0; }

		//MethodDefinition
		public RuleCall getMethodDefinitionParserRuleCall_1() { return cMethodDefinitionParserRuleCall_1; }
	}

	public class ValuesBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValuesBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cValuesBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cValuesKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cDeclarationsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDeclarationsValueDeclarationParserRuleCall_3_0 = (RuleCall)cDeclarationsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ValuesBlock:
		//	{ValuesBlock} "values" "{" declarations+=ValueDeclaration* "}";
		public ParserRule getRule() { return rule; }

		//{ValuesBlock} "values" "{" declarations+=ValueDeclaration* "}"
		public Group getGroup() { return cGroup; }

		//{ValuesBlock}
		public Action getValuesBlockAction_0() { return cValuesBlockAction_0; }

		//"values"
		public Keyword getValuesKeyword_1() { return cValuesKeyword_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//declarations+=ValueDeclaration*
		public Assignment getDeclarationsAssignment_3() { return cDeclarationsAssignment_3; }

		//ValueDeclaration
		public RuleCall getDeclarationsValueDeclarationParserRuleCall_3_0() { return cDeclarationsValueDeclarationParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class ValueDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValueDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cValueValueParserRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cDeclaredTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cDeclaredTypeTypeLiteralParserRuleCall_1_1_0 = (RuleCall)cDeclaredTypeAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cValueTypeAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cValueTypeValueTypesEnumRuleCall_2_0_0 = (RuleCall)cValueTypeAssignment_2_0.eContents().get(0);
		private final Assignment cValueExprAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueExprExpressionParserRuleCall_2_1_0 = (RuleCall)cValueExprAssignment_2_1.eContents().get(0);
		
		//ValueDeclaration:
		//	value=Value (":" declaredType=TypeLiteral)? (valueType=ValueTypes valueExpr=Expression)?;
		public ParserRule getRule() { return rule; }

		//value=Value (":" declaredType=TypeLiteral)? (valueType=ValueTypes valueExpr=Expression)?
		public Group getGroup() { return cGroup; }

		//value=Value
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }

		//Value
		public RuleCall getValueValueParserRuleCall_0_0() { return cValueValueParserRuleCall_0_0; }

		//(":" declaredType=TypeLiteral)?
		public Group getGroup_1() { return cGroup_1; }

		//":"
		public Keyword getColonKeyword_1_0() { return cColonKeyword_1_0; }

		//declaredType=TypeLiteral
		public Assignment getDeclaredTypeAssignment_1_1() { return cDeclaredTypeAssignment_1_1; }

		//TypeLiteral
		public RuleCall getDeclaredTypeTypeLiteralParserRuleCall_1_1_0() { return cDeclaredTypeTypeLiteralParserRuleCall_1_1_0; }

		//(valueType=ValueTypes valueExpr=Expression)?
		public Group getGroup_2() { return cGroup_2; }

		//valueType=ValueTypes
		public Assignment getValueTypeAssignment_2_0() { return cValueTypeAssignment_2_0; }

		//ValueTypes
		public RuleCall getValueTypeValueTypesEnumRuleCall_2_0_0() { return cValueTypeValueTypesEnumRuleCall_2_0_0; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_2_1() { return cValueExprAssignment_2_1; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_2_1_0() { return cValueExprExpressionParserRuleCall_2_1_0; }
	}

	public class ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Value");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Value:
		//	name=ID;
		public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class AbstractValueDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AbstractValueDeclaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cValueDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLocalValueDeclarationStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// (synthetic convenience type)
		//AbstractValueDeclaration:
		//	ValueDeclaration | LocalValueDeclarationStatement;
		public ParserRule getRule() { return rule; }

		//ValueDeclaration | LocalValueDeclarationStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//ValueDeclaration
		public RuleCall getValueDeclarationParserRuleCall_0() { return cValueDeclarationParserRuleCall_0; }

		//LocalValueDeclarationStatement
		public RuleCall getLocalValueDeclarationStatementParserRuleCall_1() { return cLocalValueDeclarationStatementParserRuleCall_1; }
	}

	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeLiteralParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//// validation: ( declaredType == null ) || declaredType.isAssignableFrom(valueExpr.type)	[√]
		//Parameter:
		//	name=ID ":" type=TypeLiteral;
		public ParserRule getRule() { return rule; }

		//name=ID ":" type=TypeLiteral
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//type=TypeLiteral
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//TypeLiteral
		public RuleCall getTypeTypeLiteralParserRuleCall_2_0() { return cTypeTypeLiteralParserRuleCall_2_0; }
	}

	public class ParameterListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParameterListAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParametersAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParametersParameterParserRuleCall_2_0_0 = (RuleCall)cParametersAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Alternatives cAlternatives_2_1_0 = (Alternatives)cGroup_2_1.eContents().get(0);
		private final Keyword cCommaKeyword_2_1_0_0 = (Keyword)cAlternatives_2_1_0.eContents().get(0);
		private final Keyword cVerticalLineKeyword_2_1_0_1 = (Keyword)cAlternatives_2_1_0.eContents().get(1);
		private final Assignment cParametersAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParametersParameterParserRuleCall_2_1_1_0 = (RuleCall)cParametersAssignment_2_1_1.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ParameterList:
		//	{ParameterList} "(" (parameters+=Parameter (("," | "|") parameters+=Parameter)*)? ","? ")";
		public ParserRule getRule() { return rule; }

		//{ParameterList} "(" (parameters+=Parameter (("," | "|") parameters+=Parameter)*)? ","? ")"
		public Group getGroup() { return cGroup; }

		//{ParameterList}
		public Action getParameterListAction_0() { return cParameterListAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(parameters+=Parameter (("," | "|") parameters+=Parameter)*)?
		public Group getGroup_2() { return cGroup_2; }

		//parameters+=Parameter
		public Assignment getParametersAssignment_2_0() { return cParametersAssignment_2_0; }

		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_0_0() { return cParametersParameterParserRuleCall_2_0_0; }

		//(("," | "|") parameters+=Parameter)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"," | "|"
		public Alternatives getAlternatives_2_1_0() { return cAlternatives_2_1_0; }

		//","
		public Keyword getCommaKeyword_2_1_0_0() { return cCommaKeyword_2_1_0_0; }

		//"|"
		public Keyword getVerticalLineKeyword_2_1_0_1() { return cVerticalLineKeyword_2_1_0_1; }

		//parameters+=Parameter
		public Assignment getParametersAssignment_2_1_1() { return cParametersAssignment_2_1_1; }

		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_1_1_0() { return cParametersParameterParserRuleCall_2_1_1_0; }

		//","?
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class MethodDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MethodDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMethodKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cMethodAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMethodMethodParserRuleCall_1_0 = (RuleCall)cMethodAssignment_1.eContents().get(0);
		private final Assignment cParameterListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParameterListParameterListParserRuleCall_2_0 = (RuleCall)cParameterListAssignment_2.eContents().get(0);
		private final Assignment cStatementBlockAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementBlockStatementBlockParserRuleCall_3_0 = (RuleCall)cStatementBlockAssignment_3.eContents().get(0);
		
		/// *
		//	 * Note: you can either use commas or pipes to separate parameters and you
		//	 * 			can optionally have a non-separating, trailing comma.
		//	 * 			(The intent is to prevent having a sense of implied ordering.)
		//	 * / MethodDefinition:
		//	"method" method=Method parameterList=ParameterList statementBlock=StatementBlock;
		public ParserRule getRule() { return rule; }

		//"method" method=Method parameterList=ParameterList statementBlock=StatementBlock
		public Group getGroup() { return cGroup; }

		//"method"
		public Keyword getMethodKeyword_0() { return cMethodKeyword_0; }

		//method=Method
		public Assignment getMethodAssignment_1() { return cMethodAssignment_1; }

		//Method
		public RuleCall getMethodMethodParserRuleCall_1_0() { return cMethodMethodParserRuleCall_1_0; }

		//parameterList=ParameterList
		public Assignment getParameterListAssignment_2() { return cParameterListAssignment_2; }

		//ParameterList
		public RuleCall getParameterListParameterListParserRuleCall_2_0() { return cParameterListParameterListParserRuleCall_2_0; }

		//statementBlock=StatementBlock
		public Assignment getStatementBlockAssignment_3() { return cStatementBlockAssignment_3; }

		//StatementBlock
		public RuleCall getStatementBlockStatementBlockParserRuleCall_3_0() { return cStatementBlockStatementBlockParserRuleCall_3_0; }
	}

	public class MethodElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Method");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		/// *
		//	 * semantics:
		//	 * 		The return value of a method is simply the value of the (evaluation of the) last statement - and likewise for the return type.
		//	 * 		In most cases, the return value will be null and its type will be Void - a method is a function if that's not the case.
		//	 * 		(Note that there's no return statement which'd make the statement flow more difficult to understand and analyse.)
		//	 * / Method:
		//	name=ID;
		public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class ElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Element");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cQuotationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBindingParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cComponentInvocationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBlockElementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cListElementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cTableElementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cLabeledTableElementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cProgressBarTabSetParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cGroupElementParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cWhenElementParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cInputElementParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cButtonElementParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cCountdownTimerParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		private final RuleCall cCalendarElementParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cTimeSlotListElementParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		private final RuleCall cSlotAddElementParserRuleCall_15 = (RuleCall)cAlternatives.eContents().get(15);
		private final RuleCall cImageElementParserRuleCall_16 = (RuleCall)cAlternatives.eContents().get(16);
		private final RuleCall cFrameElementParserRuleCall_17 = (RuleCall)cAlternatives.eContents().get(17);
		private final RuleCall cLineBreakElementParserRuleCall_18 = (RuleCall)cAlternatives.eContents().get(18);
		private final RuleCall cObserveElementParserRuleCall_19 = (RuleCall)cAlternatives.eContents().get(19);
		private final RuleCall cLabeledTableRowParserRuleCall_20 = (RuleCall)cAlternatives.eContents().get(20);
		
		/// *
		// * +----------+
		// * | elements |
		// * +----------+
		// * / Element:
		//	Quotation // structural elements:
		//	// other elements:
		//	| // value elements
		//	Binding | // embedding
		//	ComponentInvocation | BlockElement | ListElement | TableElement | LabeledTableElement | ProgressBarTabSet |
		//	GroupElement | WhenElement | InputElement | ButtonElement | CountdownTimer | CalendarElement | TimeSlotListElement |
		//	SlotAddElement | ImageElement | FrameElement | LineBreakElement | ObserveElement | LabeledTableRow;
		public ParserRule getRule() { return rule; }

		//Quotation // structural elements:
		//// other elements:
		//| // value elements
		//Binding | // embedding
		//ComponentInvocation | BlockElement | ListElement | TableElement | LabeledTableElement | ProgressBarTabSet | GroupElement
		//| WhenElement | InputElement | ButtonElement | CountdownTimer | CalendarElement | TimeSlotListElement | SlotAddElement
		//| ImageElement | FrameElement | LineBreakElement | ObserveElement | LabeledTableRow
		public Alternatives getAlternatives() { return cAlternatives; }

		//Quotation
		public RuleCall getQuotationParserRuleCall_0() { return cQuotationParserRuleCall_0; }

		//// value elements
		//Binding
		public RuleCall getBindingParserRuleCall_1() { return cBindingParserRuleCall_1; }

		//// embedding
		//ComponentInvocation
		public RuleCall getComponentInvocationParserRuleCall_2() { return cComponentInvocationParserRuleCall_2; }

		//BlockElement
		public RuleCall getBlockElementParserRuleCall_3() { return cBlockElementParserRuleCall_3; }

		//ListElement
		public RuleCall getListElementParserRuleCall_4() { return cListElementParserRuleCall_4; }

		//TableElement
		public RuleCall getTableElementParserRuleCall_5() { return cTableElementParserRuleCall_5; }

		//LabeledTableElement
		public RuleCall getLabeledTableElementParserRuleCall_6() { return cLabeledTableElementParserRuleCall_6; }

		//ProgressBarTabSet
		public RuleCall getProgressBarTabSetParserRuleCall_7() { return cProgressBarTabSetParserRuleCall_7; }

		//GroupElement
		public RuleCall getGroupElementParserRuleCall_8() { return cGroupElementParserRuleCall_8; }

		//WhenElement
		public RuleCall getWhenElementParserRuleCall_9() { return cWhenElementParserRuleCall_9; }

		//InputElement
		public RuleCall getInputElementParserRuleCall_10() { return cInputElementParserRuleCall_10; }

		//ButtonElement
		public RuleCall getButtonElementParserRuleCall_11() { return cButtonElementParserRuleCall_11; }

		//CountdownTimer
		public RuleCall getCountdownTimerParserRuleCall_12() { return cCountdownTimerParserRuleCall_12; }

		//CalendarElement
		public RuleCall getCalendarElementParserRuleCall_13() { return cCalendarElementParserRuleCall_13; }

		//TimeSlotListElement
		public RuleCall getTimeSlotListElementParserRuleCall_14() { return cTimeSlotListElementParserRuleCall_14; }

		//SlotAddElement
		public RuleCall getSlotAddElementParserRuleCall_15() { return cSlotAddElementParserRuleCall_15; }

		//ImageElement
		public RuleCall getImageElementParserRuleCall_16() { return cImageElementParserRuleCall_16; }

		//FrameElement
		public RuleCall getFrameElementParserRuleCall_17() { return cFrameElementParserRuleCall_17; }

		//LineBreakElement
		public RuleCall getLineBreakElementParserRuleCall_18() { return cLineBreakElementParserRuleCall_18; }

		//ObserveElement
		public RuleCall getObserveElementParserRuleCall_19() { return cObserveElementParserRuleCall_19; }

		//LabeledTableRow
		public RuleCall getLabeledTableRowParserRuleCall_20() { return cLabeledTableRowParserRuleCall_20; }
	}

	public class QuotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Quotation");
		private final Assignment cPathAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cPathExpressionParserRuleCall_0 = (RuleCall)cPathAssignment.eContents().get(0);
		
		//Quotation:
		//	path=Expression;
		public ParserRule getRule() { return rule; }

		//path=Expression
		public Assignment getPathAssignment() { return cPathAssignment; }

		//Expression
		public RuleCall getPathExpressionParserRuleCall_0() { return cPathExpressionParserRuleCall_0; }
	}

	public class BindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Binding");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBindKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBindSiteAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBindSiteExpressionParserRuleCall_2_0 = (RuleCall)cBindSiteAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Binding:
		//	"bind" "(" bindSite=Expression ")";
		public ParserRule getRule() { return rule; }

		//"bind" "(" bindSite=Expression ")"
		public Group getGroup() { return cGroup; }

		//"bind"
		public Keyword getBindKeyword_0() { return cBindKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//bindSite=Expression
		public Assignment getBindSiteAssignment_2() { return cBindSiteAssignment_2; }

		//Expression
		public RuleCall getBindSiteExpressionParserRuleCall_2_0() { return cBindSiteExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class ElementBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ElementBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cElementBodyAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cElementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElementsElementParserRuleCall_2_0 = (RuleCall)cElementsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// *
		//	 * validation: bindSite.type must be observable		[√]
		//	 * semantics: indicates a reactive expression
		//	 * / ElementBody:
		//	{ElementBody} "{" elements+=Element* "}";
		public ParserRule getRule() { return rule; }

		//{ElementBody} "{" elements+=Element* "}"
		public Group getGroup() { return cGroup; }

		//{ElementBody}
		public Action getElementBodyAction_0() { return cElementBodyAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//elements+=Element*
		public Assignment getElementsAssignment_2() { return cElementsAssignment_2; }

		//Element
		public RuleCall getElementsElementParserRuleCall_2_0() { return cElementsElementParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class ComponentInvocationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComponentInvocation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEmbedKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cViewableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cViewableViewableCrossReference_1_0 = (CrossReference)cViewableAssignment_1.eContents().get(0);
		private final RuleCall cViewableViewableIDTerminalRuleCall_1_0_1 = (RuleCall)cViewableViewableCrossReference_1_0.eContents().get(1);
		private final Assignment cArgumentListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgumentListArgumentListParserRuleCall_2_0 = (RuleCall)cArgumentListAssignment_2.eContents().get(0);
		
		//// validation: warning if elements.empty			[√]
		//ComponentInvocation:
		//	"embed" viewable=[Viewable] argumentList=ArgumentList;
		public ParserRule getRule() { return rule; }

		//"embed" viewable=[Viewable] argumentList=ArgumentList
		public Group getGroup() { return cGroup; }

		//"embed"
		public Keyword getEmbedKeyword_0() { return cEmbedKeyword_0; }

		//viewable=[Viewable]
		public Assignment getViewableAssignment_1() { return cViewableAssignment_1; }

		//[Viewable]
		public CrossReference getViewableViewableCrossReference_1_0() { return cViewableViewableCrossReference_1_0; }

		//ID
		public RuleCall getViewableViewableIDTerminalRuleCall_1_0_1() { return cViewableViewableIDTerminalRuleCall_1_0_1; }

		//argumentList=ArgumentList
		public Assignment getArgumentListAssignment_2() { return cArgumentListAssignment_2; }

		//ArgumentList
		public RuleCall getArgumentListArgumentListParserRuleCall_2_0() { return cArgumentListArgumentListParserRuleCall_2_0; }
	}

	public class ArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Argument");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cParameterAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cParameterParameterCrossReference_0_0 = (CrossReference)cParameterAssignment_0.eContents().get(0);
		private final RuleCall cParameterParameterIDTerminalRuleCall_0_0_1 = (RuleCall)cParameterParameterCrossReference_0_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueExprExpressionParserRuleCall_2_0 = (RuleCall)cValueExprAssignment_2.eContents().get(0);
		
		/// *
		//	 * validation:
		//	 * 		1-  viewable is a component																		[√]
		//	 * 		2-  all parameters of the viewable are covered by the arguments (and not more than once)		[√]
		//	 * workaround: prefixed with 'embed' to avoid parsing clash
		//	 * / // TODO  considering combining the previous 2 rules by creating a method call operator in the expressions language (&c.) - and get rid of 'embed'
		//Argument:
		//	parameter=[Parameter] "=" valueExpr=Expression;
		public ParserRule getRule() { return rule; }

		//parameter=[Parameter] "=" valueExpr=Expression
		public Group getGroup() { return cGroup; }

		//parameter=[Parameter]
		public Assignment getParameterAssignment_0() { return cParameterAssignment_0; }

		//[Parameter]
		public CrossReference getParameterParameterCrossReference_0_0() { return cParameterParameterCrossReference_0_0; }

		//ID
		public RuleCall getParameterParameterIDTerminalRuleCall_0_0_1() { return cParameterParameterIDTerminalRuleCall_0_0_1; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_2() { return cValueExprAssignment_2; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_2_0() { return cValueExprExpressionParserRuleCall_2_0; }
	}

	public class ArgumentListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArgumentList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cArgumentListAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cArgumentsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cArgumentsArgumentParserRuleCall_2_0_0 = (RuleCall)cArgumentsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cArgumentsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cArgumentsArgumentParserRuleCall_2_1_1_0 = (RuleCall)cArgumentsAssignment_2_1_1.eContents().get(0);
		private final Keyword cCommaKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// *
		//	 * scoping: parameter in containing(ComponentInvocation).viewable	[√]
		//	 * validation: parameter.type.isAssignableFrom(valueExpr.type)		[√]
		//	 * 
		//	 * Note that arguments are named, so there's no dependency on parameter order!
		//	 * / ArgumentList:
		//	{ArgumentList} "(" (arguments+=Argument (","? arguments+=Argument)* ","?)? ")";
		public ParserRule getRule() { return rule; }

		//{ArgumentList} "(" (arguments+=Argument (","? arguments+=Argument)* ","?)? ")"
		public Group getGroup() { return cGroup; }

		//{ArgumentList}
		public Action getArgumentListAction_0() { return cArgumentListAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(arguments+=Argument (","? arguments+=Argument)* ","?)?
		public Group getGroup_2() { return cGroup_2; }

		//arguments+=Argument
		public Assignment getArgumentsAssignment_2_0() { return cArgumentsAssignment_2_0; }

		//Argument
		public RuleCall getArgumentsArgumentParserRuleCall_2_0_0() { return cArgumentsArgumentParserRuleCall_2_0_0; }

		//(","? arguments+=Argument)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","?
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//arguments+=Argument
		public Assignment getArgumentsAssignment_2_1_1() { return cArgumentsAssignment_2_1_1; }

		//Argument
		public RuleCall getArgumentsArgumentParserRuleCall_2_1_1_0() { return cArgumentsArgumentParserRuleCall_2_1_1_0; }

		//","?
		public Keyword getCommaKeyword_2_2() { return cCommaKeyword_2_2; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class InputElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InputElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInputKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBindSiteAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBindSiteExpressionParserRuleCall_2_0 = (RuleCall)cBindSiteAssignment_2.eContents().get(0);
		private final UnorderedGroup cUnorderedGroup_3 = (UnorderedGroup)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cUnorderedGroup_3.eContents().get(0);
		private final Keyword cHintKeyword_3_0_0 = (Keyword)cGroup_3_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_0_1 = (Keyword)cGroup_3_0.eContents().get(1);
		private final Assignment cHintAssignment_3_0_2 = (Assignment)cGroup_3_0.eContents().get(2);
		private final RuleCall cHintSTRINGTerminalRuleCall_3_0_2_0 = (RuleCall)cHintAssignment_3_0_2.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cUnorderedGroup_3.eContents().get(1);
		private final Keyword cMinKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_1_1 = (Keyword)cGroup_3_1.eContents().get(1);
		private final Assignment cMinValueAssignment_3_1_2 = (Assignment)cGroup_3_1.eContents().get(2);
		private final RuleCall cMinValueExpressionParserRuleCall_3_1_2_0 = (RuleCall)cMinValueAssignment_3_1_2.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cUnorderedGroup_3.eContents().get(2);
		private final Keyword cMaxKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_2_1 = (Keyword)cGroup_3_2.eContents().get(1);
		private final Assignment cMaxValueAssignment_3_2_2 = (Assignment)cGroup_3_2.eContents().get(2);
		private final RuleCall cMaxValueExpressionParserRuleCall_3_2_2_0 = (RuleCall)cMaxValueAssignment_3_2_2.eContents().get(0);
		private final Assignment cRadioOptionAssignment_3_3 = (Assignment)cUnorderedGroup_3.eContents().get(3);
		private final RuleCall cRadioOptionRadioOptionParserRuleCall_3_3_0 = (RuleCall)cRadioOptionAssignment_3_3.eContents().get(0);
		private final Group cGroup_3_4 = (Group)cUnorderedGroup_3.eContents().get(4);
		private final Keyword cOnChangeKeyword_3_4_0 = (Keyword)cGroup_3_4.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_4_1 = (Keyword)cGroup_3_4.eContents().get(1);
		private final Assignment cOnChangeAssignment_3_4_2 = (Assignment)cGroup_3_4.eContents().get(2);
		private final RuleCall cOnChangeExpressionParserRuleCall_3_4_2_0 = (RuleCall)cOnChangeAssignment_3_4_2.eContents().get(0);
		private final Group cGroup_3_5 = (Group)cUnorderedGroup_3.eContents().get(5);
		private final Keyword cOnSubmitKeyword_3_5_0 = (Keyword)cGroup_3_5.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_5_1 = (Keyword)cGroup_3_5.eContents().get(1);
		private final Assignment cOnSubmitAssignment_3_5_2 = (Assignment)cGroup_3_5.eContents().get(2);
		private final RuleCall cOnSubmitExpressionParserRuleCall_3_5_2_0 = (RuleCall)cOnSubmitAssignment_3_5_2.eContents().get(0);
		private final Assignment cStructureOptionAssignment_3_6 = (Assignment)cUnorderedGroup_3.eContents().get(6);
		private final RuleCall cStructureOptionStructureOptionParserRuleCall_3_6_0 = (RuleCall)cStructureOptionAssignment_3_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/// *
		//	 * The commas are optional - for now, I might remove them later on. In the meanwhile,
		//	 * you can have a non-separating, trailing comma as well.
		//	 * 
		//	 * The reason is that whitespace tends to be provide sufficient visual separation
		//	 * and the '=' character sufficient visual binding. Also, commas have a connotation
		//	 * of implied ordering which is irrelevant here.
		//	 * / InputElement:
		//	"input" "(" bindSite=Expression (("hint" "=" hint=STRING)? // event is fired when value is changed and input field looses focus
		//	// event is fired when Enter is pressed and input is valid
		//	& ("min" "=" minValue=Expression)? & ("max" "=" maxValue=Expression)? & radioOption=RadioOption? & ("onChange" "="
		//	onChange=Expression)? & ("onSubmit" "=" onSubmit=Expression)? & structureOption=StructureOption?) ")";
		public ParserRule getRule() { return rule; }

		//"input" "(" bindSite=Expression (("hint" "=" hint=STRING)? // event is fired when value is changed and input field looses focus
		//// event is fired when Enter is pressed and input is valid
		//& ("min" "=" minValue=Expression)? & ("max" "=" maxValue=Expression)? & radioOption=RadioOption? & ("onChange" "="
		//onChange=Expression)? & ("onSubmit" "=" onSubmit=Expression)? & structureOption=StructureOption?) ")"
		public Group getGroup() { return cGroup; }

		//"input"
		public Keyword getInputKeyword_0() { return cInputKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//bindSite=Expression
		public Assignment getBindSiteAssignment_2() { return cBindSiteAssignment_2; }

		//Expression
		public RuleCall getBindSiteExpressionParserRuleCall_2_0() { return cBindSiteExpressionParserRuleCall_2_0; }

		//("hint" "=" hint=STRING)? // event is fired when value is changed and input field looses focus
		//// event is fired when Enter is pressed and input is valid
		//& ("min" "=" minValue=Expression)? & ("max" "=" maxValue=Expression)? & radioOption=RadioOption? & ("onChange" "="
		//onChange=Expression)? & ("onSubmit" "=" onSubmit=Expression)? & structureOption=StructureOption?
		public UnorderedGroup getUnorderedGroup_3() { return cUnorderedGroup_3; }

		//("hint" "=" hint=STRING)?
		public Group getGroup_3_0() { return cGroup_3_0; }

		//"hint"
		public Keyword getHintKeyword_3_0_0() { return cHintKeyword_3_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_0_1() { return cEqualsSignKeyword_3_0_1; }

		//hint=STRING
		public Assignment getHintAssignment_3_0_2() { return cHintAssignment_3_0_2; }

		//STRING
		public RuleCall getHintSTRINGTerminalRuleCall_3_0_2_0() { return cHintSTRINGTerminalRuleCall_3_0_2_0; }

		//("min" "=" minValue=Expression)?
		public Group getGroup_3_1() { return cGroup_3_1; }

		//"min"
		public Keyword getMinKeyword_3_1_0() { return cMinKeyword_3_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_1_1() { return cEqualsSignKeyword_3_1_1; }

		//minValue=Expression
		public Assignment getMinValueAssignment_3_1_2() { return cMinValueAssignment_3_1_2; }

		//Expression
		public RuleCall getMinValueExpressionParserRuleCall_3_1_2_0() { return cMinValueExpressionParserRuleCall_3_1_2_0; }

		//("max" "=" maxValue=Expression)?
		public Group getGroup_3_2() { return cGroup_3_2; }

		//"max"
		public Keyword getMaxKeyword_3_2_0() { return cMaxKeyword_3_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_2_1() { return cEqualsSignKeyword_3_2_1; }

		//maxValue=Expression
		public Assignment getMaxValueAssignment_3_2_2() { return cMaxValueAssignment_3_2_2; }

		//Expression
		public RuleCall getMaxValueExpressionParserRuleCall_3_2_2_0() { return cMaxValueExpressionParserRuleCall_3_2_2_0; }

		//radioOption=RadioOption?
		public Assignment getRadioOptionAssignment_3_3() { return cRadioOptionAssignment_3_3; }

		//RadioOption
		public RuleCall getRadioOptionRadioOptionParserRuleCall_3_3_0() { return cRadioOptionRadioOptionParserRuleCall_3_3_0; }

		//("onChange" "=" onChange=Expression)?
		public Group getGroup_3_4() { return cGroup_3_4; }

		//"onChange"
		public Keyword getOnChangeKeyword_3_4_0() { return cOnChangeKeyword_3_4_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_4_1() { return cEqualsSignKeyword_3_4_1; }

		//onChange=Expression
		public Assignment getOnChangeAssignment_3_4_2() { return cOnChangeAssignment_3_4_2; }

		//Expression
		public RuleCall getOnChangeExpressionParserRuleCall_3_4_2_0() { return cOnChangeExpressionParserRuleCall_3_4_2_0; }

		//("onSubmit" "=" onSubmit=Expression)?
		public Group getGroup_3_5() { return cGroup_3_5; }

		//"onSubmit"
		public Keyword getOnSubmitKeyword_3_5_0() { return cOnSubmitKeyword_3_5_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_5_1() { return cEqualsSignKeyword_3_5_1; }

		//onSubmit=Expression
		public Assignment getOnSubmitAssignment_3_5_2() { return cOnSubmitAssignment_3_5_2; }

		//Expression
		public RuleCall getOnSubmitExpressionParserRuleCall_3_5_2_0() { return cOnSubmitExpressionParserRuleCall_3_5_2_0; }

		//structureOption=StructureOption?
		public Assignment getStructureOptionAssignment_3_6() { return cStructureOptionAssignment_3_6; }

		//StructureOption
		public RuleCall getStructureOptionStructureOptionParserRuleCall_3_6_0() { return cStructureOptionStructureOptionParserRuleCall_3_6_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class RadioOptionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RadioOption");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRadioKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTrueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTrueSTRINGTerminalRuleCall_3_0 = (RuleCall)cTrueAssignment_3.eContents().get(0);
		private final Keyword cSolidusKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cFalseAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cFalseSTRINGTerminalRuleCall_5_0 = (RuleCall)cFalseAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		/// *
		//	 * validation:
		//	 * 		1-  bindSite must be a proper target/valid left-hand side			[√]
		//	 * 		2-	bindSite must not be a callback- or void-typed 					[√]
		//	 * 		x-  warning given for types on which hint is not supported			[√]
		//	 * 		3-  min/max only allowed if bindSite is numerically-typed			[√]
		//	 * 		4-	min&max must be numerically-typed								[√]
		//	 * 		5-  radioOption can only be given if bindSite is boolean-typed		[√]
		//	 * 		6-  onChange.type == Callback										[√]
		//	 * 		y-  warning given for unsupported onChange option					[√]
		//	 * 		7-  structure option required <==> input is structure-typed 		[√]
		//	 * 		8-  warning given for (potentially) uninitialized enum fields		[ ]		TODO  OR fix FIXME in JS framework/widgets code
		//	 * 		9-  onSumbit.type == Callback										[√]
		//	 * / // semantics: corresponds to an HTML input element, with the hint being given for (at least) textually-typed fields
		//// TODO  add length option (which is supported by some of the widgets)?
		//RadioOption:
		//	"radio" "=" "{" true=STRING "/" false=STRING "}";
		public ParserRule getRule() { return rule; }

		//"radio" "=" "{" true=STRING "/" false=STRING "}"
		public Group getGroup() { return cGroup; }

		//"radio"
		public Keyword getRadioKeyword_0() { return cRadioKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//true=STRING
		public Assignment getTrueAssignment_3() { return cTrueAssignment_3; }

		//STRING
		public RuleCall getTrueSTRINGTerminalRuleCall_3_0() { return cTrueSTRINGTerminalRuleCall_3_0; }

		//"/"
		public Keyword getSolidusKeyword_4() { return cSolidusKeyword_4; }

		//false=STRING
		public Assignment getFalseAssignment_5() { return cFalseAssignment_5; }

		//STRING
		public RuleCall getFalseSTRINGTerminalRuleCall_5_0() { return cFalseSTRINGTerminalRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class StructureOptionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StructureOption");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSourceKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cSourceExprAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSourceExprExpressionParserRuleCall_3_0 = (RuleCall)cSourceExprAssignment_3.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cDisplayFunctionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final CrossReference cDisplayFunctionMethodCrossReference_5_0 = (CrossReference)cDisplayFunctionAssignment_5.eContents().get(0);
		private final RuleCall cDisplayFunctionMethodIDTerminalRuleCall_5_0_1 = (RuleCall)cDisplayFunctionMethodCrossReference_5_0.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//StructureOption:
		//	"source" "=" "{" sourceExpr=Expression "->" displayFunction=[Method] "}";
		public ParserRule getRule() { return rule; }

		//"source" "=" "{" sourceExpr=Expression "->" displayFunction=[Method] "}"
		public Group getGroup() { return cGroup; }

		//"source"
		public Keyword getSourceKeyword_0() { return cSourceKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//sourceExpr=Expression
		public Assignment getSourceExprAssignment_3() { return cSourceExprAssignment_3; }

		//Expression
		public RuleCall getSourceExprExpressionParserRuleCall_3_0() { return cSourceExprExpressionParserRuleCall_3_0; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_4() { return cHyphenMinusGreaterThanSignKeyword_4; }

		//displayFunction=[Method]
		public Assignment getDisplayFunctionAssignment_5() { return cDisplayFunctionAssignment_5; }

		//[Method]
		public CrossReference getDisplayFunctionMethodCrossReference_5_0() { return cDisplayFunctionMethodCrossReference_5_0; }

		//ID
		public RuleCall getDisplayFunctionMethodIDTerminalRuleCall_5_0_1() { return cDisplayFunctionMethodIDTerminalRuleCall_5_0_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class ButtonElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ButtonElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cButtonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final UnorderedGroup cUnorderedGroup_2 = (UnorderedGroup)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cUnorderedGroup_2.eContents().get(0);
		private final Keyword cTextKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_0_1 = (Keyword)cGroup_2_0.eContents().get(1);
		private final Assignment cTextAssignment_2_0_2 = (Assignment)cGroup_2_0.eContents().get(2);
		private final RuleCall cTextSTRINGTerminalRuleCall_2_0_2_0 = (RuleCall)cTextAssignment_2_0_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cUnorderedGroup_2.eContents().get(1);
		private final Keyword cOnClickKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_1_1 = (Keyword)cGroup_2_1.eContents().get(1);
		private final Assignment cActionAssignment_2_1_2 = (Assignment)cGroup_2_1.eContents().get(2);
		private final RuleCall cActionExpressionParserRuleCall_2_1_2_0 = (RuleCall)cActionAssignment_2_1_2.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cUnorderedGroup_2.eContents().get(2);
		private final Keyword cClassKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_2_1 = (Keyword)cGroup_2_2.eContents().get(1);
		private final Assignment cCssClassAssignment_2_2_2 = (Assignment)cGroup_2_2.eContents().get(2);
		private final RuleCall cCssClassSTRINGTerminalRuleCall_2_2_2_0 = (RuleCall)cCssClassAssignment_2_2_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// *
		//	 * validation:
		//	 * 		1-  source must be list-typed with structure type as item type		[√]
		//	 * 		2-  displayFunction must refer a function of signature
		//	 * 				(bindSite.type.listItemType) -> String (i.e., a closure)	[√]
		//	 * / ButtonElement:
		//	"button" "(" ("text" "=" text=STRING & "onClick" "=" action=Expression & ("class" "=" cssClass=STRING)?) ")";
		public ParserRule getRule() { return rule; }

		//"button" "(" ("text" "=" text=STRING & "onClick" "=" action=Expression & ("class" "=" cssClass=STRING)?) ")"
		public Group getGroup() { return cGroup; }

		//"button"
		public Keyword getButtonKeyword_0() { return cButtonKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//"text" "=" text=STRING & "onClick" "=" action=Expression & ("class" "=" cssClass=STRING)?
		public UnorderedGroup getUnorderedGroup_2() { return cUnorderedGroup_2; }

		//"text" "=" text=STRING
		public Group getGroup_2_0() { return cGroup_2_0; }

		//"text"
		public Keyword getTextKeyword_2_0_0() { return cTextKeyword_2_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_0_1() { return cEqualsSignKeyword_2_0_1; }

		//text=STRING
		public Assignment getTextAssignment_2_0_2() { return cTextAssignment_2_0_2; }

		//STRING
		public RuleCall getTextSTRINGTerminalRuleCall_2_0_2_0() { return cTextSTRINGTerminalRuleCall_2_0_2_0; }

		//"onClick" "=" action=Expression
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"onClick"
		public Keyword getOnClickKeyword_2_1_0() { return cOnClickKeyword_2_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_1_1() { return cEqualsSignKeyword_2_1_1; }

		//action=Expression
		public Assignment getActionAssignment_2_1_2() { return cActionAssignment_2_1_2; }

		//Expression
		public RuleCall getActionExpressionParserRuleCall_2_1_2_0() { return cActionExpressionParserRuleCall_2_1_2_0; }

		//("class" "=" cssClass=STRING)?
		public Group getGroup_2_2() { return cGroup_2_2; }

		//"class"
		public Keyword getClassKeyword_2_2_0() { return cClassKeyword_2_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_2_1() { return cEqualsSignKeyword_2_2_1; }

		//cssClass=STRING
		public Assignment getCssClassAssignment_2_2_2() { return cCssClassAssignment_2_2_2; }

		//STRING
		public RuleCall getCssClassSTRINGTerminalRuleCall_2_2_2_0() { return cCssClassSTRINGTerminalRuleCall_2_2_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class BlockElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBlockKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final UnorderedGroup cUnorderedGroup_2 = (UnorderedGroup)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cUnorderedGroup_2.eContents().get(0);
		private final Keyword cOnClickKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_0_1 = (Keyword)cGroup_2_0.eContents().get(1);
		private final Assignment cOnClickAssignment_2_0_2 = (Assignment)cGroup_2_0.eContents().get(2);
		private final RuleCall cOnClickExpressionParserRuleCall_2_0_2_0 = (RuleCall)cOnClickAssignment_2_0_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cUnorderedGroup_2.eContents().get(1);
		private final Keyword cClassKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_1_1 = (Keyword)cGroup_2_1.eContents().get(1);
		private final Assignment cCssClassAssignment_2_1_2 = (Assignment)cGroup_2_1.eContents().get(2);
		private final RuleCall cCssClassSTRINGTerminalRuleCall_2_1_2_0 = (RuleCall)cCssClassAssignment_2_1_2.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cUnorderedGroup_2.eContents().get(2);
		private final Keyword cBodyClassKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_2_1 = (Keyword)cGroup_2_2.eContents().get(1);
		private final Assignment cBodyCssClassAssignment_2_2_2 = (Assignment)cGroup_2_2.eContents().get(2);
		private final RuleCall cBodyCssClassSTRINGTerminalRuleCall_2_2_2_0 = (RuleCall)cBodyCssClassAssignment_2_2_2.eContents().get(0);
		private final Group cGroup_2_3 = (Group)cUnorderedGroup_2.eContents().get(3);
		private final Keyword cStyleKeyword_2_3_0 = (Keyword)cGroup_2_3.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_3_1 = (Keyword)cGroup_2_3.eContents().get(1);
		private final Assignment cStyleAssignment_2_3_2 = (Assignment)cGroup_2_3.eContents().get(2);
		private final RuleCall cStyleSTRINGTerminalRuleCall_2_3_2_0 = (RuleCall)cStyleAssignment_2_3_2.eContents().get(0);
		private final Group cGroup_2_4 = (Group)cUnorderedGroup_2.eContents().get(4);
		private final Keyword cHeaderKeyword_2_4_0 = (Keyword)cGroup_2_4.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_4_1 = (Keyword)cGroup_2_4.eContents().get(1);
		private final Assignment cHeaderAssignment_2_4_2 = (Assignment)cGroup_2_4.eContents().get(2);
		private final RuleCall cHeaderElementBodyParserRuleCall_2_4_2_0 = (RuleCall)cHeaderAssignment_2_4_2.eContents().get(0);
		private final Group cGroup_2_5 = (Group)cUnorderedGroup_2.eContents().get(5);
		private final Keyword cHeaderClassKeyword_2_5_0 = (Keyword)cGroup_2_5.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_5_1 = (Keyword)cGroup_2_5.eContents().get(1);
		private final Assignment cHeaderCssClassAssignment_2_5_2 = (Assignment)cGroup_2_5.eContents().get(2);
		private final RuleCall cHeaderCssClassSTRINGTerminalRuleCall_2_5_2_0 = (RuleCall)cHeaderCssClassAssignment_2_5_2.eContents().get(0);
		private final Assignment cNoCssAssignment_2_6 = (Assignment)cUnorderedGroup_2.eContents().get(6);
		private final Keyword cNoCssNoCssKeyword_2_6_0 = (Keyword)cNoCssAssignment_2_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBodyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBodyElementBodyParserRuleCall_4_0 = (RuleCall)cBodyAssignment_4.eContents().get(0);
		
		/// *
		//	 * validation: action.type == Callback				[√]
		//	 * design decision: `action` needs to be an Expression because we want to be able to refer to passed callbacks (and such)
		//	 * / BlockElement:
		//	"block" "(" (("onClick" "=" onClick=Expression)? & ("class" "=" cssClass=STRING)? & ("bodyClass" "="
		//	bodyCssClass=STRING)? & ("style" "=" style=STRING)? & ("header" "=" header=ElementBody)? & ("headerClass" "="
		//	headerCssClass=STRING)? & noCss?="noCss"?) ")" body=ElementBody;
		public ParserRule getRule() { return rule; }

		//"block" "(" (("onClick" "=" onClick=Expression)? & ("class" "=" cssClass=STRING)? & ("bodyClass" "="
		//bodyCssClass=STRING)? & ("style" "=" style=STRING)? & ("header" "=" header=ElementBody)? & ("headerClass" "="
		//headerCssClass=STRING)? & noCss?="noCss"?) ")" body=ElementBody
		public Group getGroup() { return cGroup; }

		//"block"
		public Keyword getBlockKeyword_0() { return cBlockKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//("onClick" "=" onClick=Expression)? & ("class" "=" cssClass=STRING)? & ("bodyClass" "=" bodyCssClass=STRING)? & ("style"
		//"=" style=STRING)? & ("header" "=" header=ElementBody)? & ("headerClass" "=" headerCssClass=STRING)? & noCss?="noCss"?
		public UnorderedGroup getUnorderedGroup_2() { return cUnorderedGroup_2; }

		//("onClick" "=" onClick=Expression)?
		public Group getGroup_2_0() { return cGroup_2_0; }

		//"onClick"
		public Keyword getOnClickKeyword_2_0_0() { return cOnClickKeyword_2_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_0_1() { return cEqualsSignKeyword_2_0_1; }

		//onClick=Expression
		public Assignment getOnClickAssignment_2_0_2() { return cOnClickAssignment_2_0_2; }

		//Expression
		public RuleCall getOnClickExpressionParserRuleCall_2_0_2_0() { return cOnClickExpressionParserRuleCall_2_0_2_0; }

		//("class" "=" cssClass=STRING)?
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"class"
		public Keyword getClassKeyword_2_1_0() { return cClassKeyword_2_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_1_1() { return cEqualsSignKeyword_2_1_1; }

		//cssClass=STRING
		public Assignment getCssClassAssignment_2_1_2() { return cCssClassAssignment_2_1_2; }

		//STRING
		public RuleCall getCssClassSTRINGTerminalRuleCall_2_1_2_0() { return cCssClassSTRINGTerminalRuleCall_2_1_2_0; }

		//("bodyClass" "=" bodyCssClass=STRING)?
		public Group getGroup_2_2() { return cGroup_2_2; }

		//"bodyClass"
		public Keyword getBodyClassKeyword_2_2_0() { return cBodyClassKeyword_2_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_2_1() { return cEqualsSignKeyword_2_2_1; }

		//bodyCssClass=STRING
		public Assignment getBodyCssClassAssignment_2_2_2() { return cBodyCssClassAssignment_2_2_2; }

		//STRING
		public RuleCall getBodyCssClassSTRINGTerminalRuleCall_2_2_2_0() { return cBodyCssClassSTRINGTerminalRuleCall_2_2_2_0; }

		//("style" "=" style=STRING)?
		public Group getGroup_2_3() { return cGroup_2_3; }

		//"style"
		public Keyword getStyleKeyword_2_3_0() { return cStyleKeyword_2_3_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_3_1() { return cEqualsSignKeyword_2_3_1; }

		//style=STRING
		public Assignment getStyleAssignment_2_3_2() { return cStyleAssignment_2_3_2; }

		//STRING
		public RuleCall getStyleSTRINGTerminalRuleCall_2_3_2_0() { return cStyleSTRINGTerminalRuleCall_2_3_2_0; }

		//("header" "=" header=ElementBody)?
		public Group getGroup_2_4() { return cGroup_2_4; }

		//"header"
		public Keyword getHeaderKeyword_2_4_0() { return cHeaderKeyword_2_4_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_4_1() { return cEqualsSignKeyword_2_4_1; }

		//header=ElementBody
		public Assignment getHeaderAssignment_2_4_2() { return cHeaderAssignment_2_4_2; }

		//ElementBody
		public RuleCall getHeaderElementBodyParserRuleCall_2_4_2_0() { return cHeaderElementBodyParserRuleCall_2_4_2_0; }

		//("headerClass" "=" headerCssClass=STRING)?
		public Group getGroup_2_5() { return cGroup_2_5; }

		//"headerClass"
		public Keyword getHeaderClassKeyword_2_5_0() { return cHeaderClassKeyword_2_5_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_5_1() { return cEqualsSignKeyword_2_5_1; }

		//headerCssClass=STRING
		public Assignment getHeaderCssClassAssignment_2_5_2() { return cHeaderCssClassAssignment_2_5_2; }

		//STRING
		public RuleCall getHeaderCssClassSTRINGTerminalRuleCall_2_5_2_0() { return cHeaderCssClassSTRINGTerminalRuleCall_2_5_2_0; }

		//noCss?="noCss"?
		public Assignment getNoCssAssignment_2_6() { return cNoCssAssignment_2_6; }

		//"noCss"
		public Keyword getNoCssNoCssKeyword_2_6_0() { return cNoCssNoCssKeyword_2_6_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//body=ElementBody
		public Assignment getBodyAssignment_4() { return cBodyAssignment_4; }

		//ElementBody
		public RuleCall getBodyElementBodyParserRuleCall_4_0() { return cBodyElementBodyParserRuleCall_4_0; }
	}

	public class ListElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ListElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cListKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cIndexVariableAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cIndexVariableListVariableParserRuleCall_3_0 = (RuleCall)cIndexVariableAssignment_3.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValueVariableAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValueVariableListVariableParserRuleCall_5_0 = (RuleCall)cValueVariableAssignment_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cInKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cListExpressionAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cListExpressionExpressionParserRuleCall_8_0 = (RuleCall)cListExpressionAssignment_8.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Assignment cBodyAssignment_10 = (Assignment)cGroup.eContents().get(10);
		private final RuleCall cBodyElementBodyParserRuleCall_10_0 = (RuleCall)cBodyAssignment_10.eContents().get(0);
		
		/// *
		//	 * validation: onClick.type == Callback				[√] 
		//	 * / ListElement:
		//	"list" "(" "(" indexVariable=ListVariable "->" valueVariable=ListVariable ")" "in" listExpression=Expression ")"
		//	body=ElementBody;
		public ParserRule getRule() { return rule; }

		//"list" "(" "(" indexVariable=ListVariable "->" valueVariable=ListVariable ")" "in" listExpression=Expression ")"
		//body=ElementBody
		public Group getGroup() { return cGroup; }

		//"list"
		public Keyword getListKeyword_0() { return cListKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//indexVariable=ListVariable
		public Assignment getIndexVariableAssignment_3() { return cIndexVariableAssignment_3; }

		//ListVariable
		public RuleCall getIndexVariableListVariableParserRuleCall_3_0() { return cIndexVariableListVariableParserRuleCall_3_0; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_4() { return cHyphenMinusGreaterThanSignKeyword_4; }

		//valueVariable=ListVariable
		public Assignment getValueVariableAssignment_5() { return cValueVariableAssignment_5; }

		//ListVariable
		public RuleCall getValueVariableListVariableParserRuleCall_5_0() { return cValueVariableListVariableParserRuleCall_5_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//"in"
		public Keyword getInKeyword_7() { return cInKeyword_7; }

		//listExpression=Expression
		public Assignment getListExpressionAssignment_8() { return cListExpressionAssignment_8; }

		//Expression
		public RuleCall getListExpressionExpressionParserRuleCall_8_0() { return cListExpressionExpressionParserRuleCall_8_0; }

		//")"
		public Keyword getRightParenthesisKeyword_9() { return cRightParenthesisKeyword_9; }

		//body=ElementBody
		public Assignment getBodyAssignment_10() { return cBodyAssignment_10; }

		//ElementBody
		public RuleCall getBodyElementBodyParserRuleCall_10_0() { return cBodyElementBodyParserRuleCall_10_0; }
	}

	public class ListVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ListVariable");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//// validation: listExpression.type.arrayTyped		[√]
		//// TODO  add element that serves as a deletion mechanism
		//ListVariable:
		//	name=ID;
		public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class TableElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TableElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTableElementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTableKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cSubElementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSubElementsTableBodyElementParserRuleCall_3_0 = (RuleCall)cSubElementsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//TableElement:
		//	{TableElement} "table" "{" subElements+=TableBodyElement* "}";
		public ParserRule getRule() { return rule; }

		//{TableElement} "table" "{" subElements+=TableBodyElement* "}"
		public Group getGroup() { return cGroup; }

		//{TableElement}
		public Action getTableElementAction_0() { return cTableElementAction_0; }

		//"table"
		public Keyword getTableKeyword_1() { return cTableKeyword_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//subElements+=TableBodyElement*
		public Assignment getSubElementsAssignment_3() { return cSubElementsAssignment_3; }

		//TableBodyElement
		public RuleCall getSubElementsTableBodyElementParserRuleCall_3_0() { return cSubElementsTableBodyElementParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class TableBodyElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TableBodyElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTableRowParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTableRowsInvocationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// validation: warning if subElements.empty								[√]
		//TableBodyElement:
		//	TableRow | TableRowsInvocation;
		public ParserRule getRule() { return rule; }

		//TableRow | TableRowsInvocation
		public Alternatives getAlternatives() { return cAlternatives; }

		//TableRow
		public RuleCall getTableRowParserRuleCall_0() { return cTableRowParserRuleCall_0; }

		//TableRowsInvocation
		public RuleCall getTableRowsInvocationParserRuleCall_1() { return cTableRowsInvocationParserRuleCall_1; }
	}

	public class TableRowsInvocationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TableRowsInvocation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEmbedKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDefinitionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cDefinitionTableRowsDefinitionCrossReference_1_0 = (CrossReference)cDefinitionAssignment_1.eContents().get(0);
		private final RuleCall cDefinitionTableRowsDefinitionIDTerminalRuleCall_1_0_1 = (RuleCall)cDefinitionTableRowsDefinitionCrossReference_1_0.eContents().get(1);
		private final Assignment cArgumentListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgumentListArgumentListParserRuleCall_2_0 = (RuleCall)cArgumentListAssignment_2.eContents().get(0);
		
		//TableRowsInvocation:
		//	"embed" definition=[TableRowsDefinition] argumentList=ArgumentList;
		public ParserRule getRule() { return rule; }

		//"embed" definition=[TableRowsDefinition] argumentList=ArgumentList
		public Group getGroup() { return cGroup; }

		//"embed"
		public Keyword getEmbedKeyword_0() { return cEmbedKeyword_0; }

		//definition=[TableRowsDefinition]
		public Assignment getDefinitionAssignment_1() { return cDefinitionAssignment_1; }

		//[TableRowsDefinition]
		public CrossReference getDefinitionTableRowsDefinitionCrossReference_1_0() { return cDefinitionTableRowsDefinitionCrossReference_1_0; }

		//ID
		public RuleCall getDefinitionTableRowsDefinitionIDTerminalRuleCall_1_0_1() { return cDefinitionTableRowsDefinitionIDTerminalRuleCall_1_0_1; }

		//argumentList=ArgumentList
		public Assignment getArgumentListAssignment_2() { return cArgumentListAssignment_2; }

		//ArgumentList
		public RuleCall getArgumentListArgumentListParserRuleCall_2_0() { return cArgumentListArgumentListParserRuleCall_2_0; }
	}

	public class TableRowElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TableRow");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLabelAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLabelExpressionParserRuleCall_0_0 = (RuleCall)cLabelAssignment_0.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyElementBodyParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		
		//TableRow:
		//	label=Expression body= // the implicit, quasi-non-LL(*) kind
		//	ElementBody;
		public ParserRule getRule() { return rule; }

		//label=Expression body= // the implicit, quasi-non-LL(*) kind
		//ElementBody
		public Group getGroup() { return cGroup; }

		//label=Expression
		public Assignment getLabelAssignment_0() { return cLabelAssignment_0; }

		//Expression
		public RuleCall getLabelExpressionParserRuleCall_0_0() { return cLabelExpressionParserRuleCall_0_0; }

		//body= // the implicit, quasi-non-LL(*) kind
		//ElementBody
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }

		//// the implicit, quasi-non-LL(*) kind
		//ElementBody
		public RuleCall getBodyElementBodyParserRuleCall_1_0() { return cBodyElementBodyParserRuleCall_1_0; }
	}

	public class LabeledTableElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LabeledTableElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLabeledTableElementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLabeledTableKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBodyElementBodyParserRuleCall_2_0 = (RuleCall)cBodyAssignment_2.eContents().get(0);
		
		//// validation: label.type = STRING										[√]
		//LabeledTableElement:
		//	{LabeledTableElement} "labeled-table" body=ElementBody;
		public ParserRule getRule() { return rule; }

		//{LabeledTableElement} "labeled-table" body=ElementBody
		public Group getGroup() { return cGroup; }

		//{LabeledTableElement}
		public Action getLabeledTableElementAction_0() { return cLabeledTableElementAction_0; }

		//"labeled-table"
		public Keyword getLabeledTableKeyword_1() { return cLabeledTableKeyword_1; }

		//body=ElementBody
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }

		//ElementBody
		public RuleCall getBodyElementBodyParserRuleCall_2_0() { return cBodyElementBodyParserRuleCall_2_0; }
	}

	public class LabeledTableRowElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LabeledTableRow");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLabelKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLabelAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLabelExpressionParserRuleCall_2_0 = (RuleCall)cLabelAssignment_2.eContents().get(0);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyElementBodyParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		
		//// validate: all directly-contained, non-structural elements are a LabeledTableRow	[√]
		//LabeledTableRow:
		//	"label" "=" label=Expression body= // the explicit, LL(*) kind
		//	ElementBody;
		public ParserRule getRule() { return rule; }

		//"label" "=" label=Expression body= // the explicit, LL(*) kind
		//ElementBody
		public Group getGroup() { return cGroup; }

		//"label"
		public Keyword getLabelKeyword_0() { return cLabelKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//label=Expression
		public Assignment getLabelAssignment_2() { return cLabelAssignment_2; }

		//Expression
		public RuleCall getLabelExpressionParserRuleCall_2_0() { return cLabelExpressionParserRuleCall_2_0; }

		//body= // the explicit, LL(*) kind
		//ElementBody
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }

		//// the explicit, LL(*) kind
		//ElementBody
		public RuleCall getBodyElementBodyParserRuleCall_3_0() { return cBodyElementBodyParserRuleCall_3_0; }
	}

	public class ProgressBarTabSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProgressBarTabSet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cProgressBarTabSetAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cProgressBarTabSetKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTabsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTabsTabDeclarationParserRuleCall_3_0 = (RuleCall)cTabsAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// validation: label.type = STRING										[√]
		//ProgressBarTabSet:
		//	{ProgressBarTabSet} "progressBarTabSet" "(" tabs+=TabDeclaration* ")";
		public ParserRule getRule() { return rule; }

		//{ProgressBarTabSet} "progressBarTabSet" "(" tabs+=TabDeclaration* ")"
		public Group getGroup() { return cGroup; }

		//{ProgressBarTabSet}
		public Action getProgressBarTabSetAction_0() { return cProgressBarTabSetAction_0; }

		//"progressBarTabSet"
		public Keyword getProgressBarTabSetKeyword_1() { return cProgressBarTabSetKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//tabs+=TabDeclaration*
		public Assignment getTabsAssignment_3() { return cTabsAssignment_3; }

		//TabDeclaration
		public RuleCall getTabsTabDeclarationParserRuleCall_3_0() { return cTabsTabDeclarationParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class TabDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TabDeclaration");
		private final UnorderedGroup cUnorderedGroup = (UnorderedGroup)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cUnorderedGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cHeaderKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_0_1_1 = (Keyword)cGroup_0_1.eContents().get(1);
		private final Assignment cHeaderAssignment_0_1_2 = (Assignment)cGroup_0_1.eContents().get(2);
		private final RuleCall cHeaderElementBodyParserRuleCall_0_1_2_0 = (RuleCall)cHeaderAssignment_0_1_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cUnorderedGroup.eContents().get(1);
		private final Keyword cComponentKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cViewableAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final CrossReference cViewableViewableCrossReference_1_2_0 = (CrossReference)cViewableAssignment_1_2.eContents().get(0);
		private final RuleCall cViewableViewableIDTerminalRuleCall_1_2_0_1 = (RuleCall)cViewableViewableCrossReference_1_2_0.eContents().get(1);
		private final Assignment cArgumentListAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cArgumentListArgumentListParserRuleCall_1_3_0 = (RuleCall)cArgumentListAssignment_1_3.eContents().get(0);
		private final Group cGroup_2 = (Group)cUnorderedGroup.eContents().get(2);
		private final Keyword cPreviousKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cPreviousCallbackAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cPreviousCallbackCallbackExpressionParserRuleCall_2_2_0 = (RuleCall)cPreviousCallbackAssignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cUnorderedGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cGroup_3.eContents().get(0);
		private final Keyword cNextKeyword_3_0_0 = (Keyword)cGroup_3_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_0_1 = (Keyword)cGroup_3_0.eContents().get(1);
		private final Assignment cNextCallbackAssignment_3_0_2 = (Assignment)cGroup_3_0.eContents().get(2);
		private final RuleCall cNextCallbackCallbackExpressionParserRuleCall_3_0_2_0 = (RuleCall)cNextCallbackAssignment_3_0_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		
		//// validation: warning if #tabs == 0				[√]
		//TabDeclaration:
		//	"{" ("header" "=" header=ElementBody) & "component" "=" viewable=[Viewable] argumentList=ArgumentList & ("previous"
		//	"=" previousCallback=CallbackExpression)? & ("next" "=" nextCallback=CallbackExpression)? "}";
		public ParserRule getRule() { return rule; }

		//"{" ("header" "=" header=ElementBody) & "component" "=" viewable=[Viewable] argumentList=ArgumentList & ("previous" "="
		//previousCallback=CallbackExpression)? & ("next" "=" nextCallback=CallbackExpression)? "}"
		public UnorderedGroup getUnorderedGroup() { return cUnorderedGroup; }

		//"{" ("header" "=" header=ElementBody)
		public Group getGroup_0() { return cGroup_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0_0() { return cLeftCurlyBracketKeyword_0_0; }

		//"header" "=" header=ElementBody
		public Group getGroup_0_1() { return cGroup_0_1; }

		//"header"
		public Keyword getHeaderKeyword_0_1_0() { return cHeaderKeyword_0_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_0_1_1() { return cEqualsSignKeyword_0_1_1; }

		//header=ElementBody
		public Assignment getHeaderAssignment_0_1_2() { return cHeaderAssignment_0_1_2; }

		//ElementBody
		public RuleCall getHeaderElementBodyParserRuleCall_0_1_2_0() { return cHeaderElementBodyParserRuleCall_0_1_2_0; }

		//"component" "=" viewable=[Viewable] argumentList=ArgumentList
		public Group getGroup_1() { return cGroup_1; }

		//"component"
		public Keyword getComponentKeyword_1_0() { return cComponentKeyword_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_1_1() { return cEqualsSignKeyword_1_1; }

		//viewable=[Viewable]
		public Assignment getViewableAssignment_1_2() { return cViewableAssignment_1_2; }

		//[Viewable]
		public CrossReference getViewableViewableCrossReference_1_2_0() { return cViewableViewableCrossReference_1_2_0; }

		//ID
		public RuleCall getViewableViewableIDTerminalRuleCall_1_2_0_1() { return cViewableViewableIDTerminalRuleCall_1_2_0_1; }

		//argumentList=ArgumentList
		public Assignment getArgumentListAssignment_1_3() { return cArgumentListAssignment_1_3; }

		//ArgumentList
		public RuleCall getArgumentListArgumentListParserRuleCall_1_3_0() { return cArgumentListArgumentListParserRuleCall_1_3_0; }

		//("previous" "=" previousCallback=CallbackExpression)?
		public Group getGroup_2() { return cGroup_2; }

		//"previous"
		public Keyword getPreviousKeyword_2_0() { return cPreviousKeyword_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_1() { return cEqualsSignKeyword_2_1; }

		//previousCallback=CallbackExpression
		public Assignment getPreviousCallbackAssignment_2_2() { return cPreviousCallbackAssignment_2_2; }

		//CallbackExpression
		public RuleCall getPreviousCallbackCallbackExpressionParserRuleCall_2_2_0() { return cPreviousCallbackCallbackExpressionParserRuleCall_2_2_0; }

		//("next" "=" nextCallback=CallbackExpression)? "}"
		public Group getGroup_3() { return cGroup_3; }

		//("next" "=" nextCallback=CallbackExpression)?
		public Group getGroup_3_0() { return cGroup_3_0; }

		//"next"
		public Keyword getNextKeyword_3_0_0() { return cNextKeyword_3_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_0_1() { return cEqualsSignKeyword_3_0_1; }

		//nextCallback=CallbackExpression
		public Assignment getNextCallbackAssignment_3_0_2() { return cNextCallbackAssignment_3_0_2; }

		//CallbackExpression
		public RuleCall getNextCallbackCallbackExpressionParserRuleCall_3_0_2_0() { return cNextCallbackCallbackExpressionParserRuleCall_3_0_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3_1() { return cRightCurlyBracketKeyword_3_1; }
	}

	public class GroupElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroupElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGroupElementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cGroupKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Keyword cOrientationKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cOrientationAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cOrientationGroupOrientationsEnumRuleCall_2_3_0 = (RuleCall)cOrientationAssignment_2_3.eContents().get(0);
		private final Group cGroup_2_4 = (Group)cGroup_2.eContents().get(4);
		private final Keyword cVAlignKeyword_2_4_0 = (Keyword)cGroup_2_4.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_4_1 = (Keyword)cGroup_2_4.eContents().get(1);
		private final Assignment cV_alignAssignment_2_4_2 = (Assignment)cGroup_2_4.eContents().get(2);
		private final RuleCall cV_alignVerticalAlignmentEnumRuleCall_2_4_2_0 = (RuleCall)cV_alignAssignment_2_4_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_5 = (Keyword)cGroup_2.eContents().get(5);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Assignment cNestedGroupsAssignment_4_0 = (Assignment)cAlternatives_4.eContents().get(0);
		private final RuleCall cNestedGroupsGroupElementParserRuleCall_4_0_0 = (RuleCall)cNestedGroupsAssignment_4_0.eContents().get(0);
		private final Assignment cLeafGroupsAssignment_4_1 = (Assignment)cAlternatives_4.eContents().get(1);
		private final RuleCall cLeafGroupsElementBodyParserRuleCall_4_1_0 = (RuleCall)cLeafGroupsAssignment_4_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		/// *
		//	 * validation:
		//	 * 		1-  title must be string-typed				[√]
		//	 * 		2-  viewable must be a component			[√]
		//	 * / // TODO  remove this construct as we seem to prefer using block-s with CSS
		//GroupElement:
		//	{GroupElement} "group" ("(" "orientation" "=" orientation=GroupOrientations ("v-align" "=" v_align=VerticalAlignment)?
		//	")")? "{" (nestedGroups+=GroupElement+ | leafGroups+=ElementBody+) "}";
		public ParserRule getRule() { return rule; }

		//{GroupElement} "group" ("(" "orientation" "=" orientation=GroupOrientations ("v-align" "=" v_align=VerticalAlignment)?
		//")")? "{" (nestedGroups+=GroupElement+ | leafGroups+=ElementBody+) "}"
		public Group getGroup() { return cGroup; }

		//{GroupElement}
		public Action getGroupElementAction_0() { return cGroupElementAction_0; }

		//"group"
		public Keyword getGroupKeyword_1() { return cGroupKeyword_1; }

		//("(" "orientation" "=" orientation=GroupOrientations ("v-align" "=" v_align=VerticalAlignment)? ")")?
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//"orientation"
		public Keyword getOrientationKeyword_2_1() { return cOrientationKeyword_2_1; }

		//"="
		public Keyword getEqualsSignKeyword_2_2() { return cEqualsSignKeyword_2_2; }

		//orientation=GroupOrientations
		public Assignment getOrientationAssignment_2_3() { return cOrientationAssignment_2_3; }

		//GroupOrientations
		public RuleCall getOrientationGroupOrientationsEnumRuleCall_2_3_0() { return cOrientationGroupOrientationsEnumRuleCall_2_3_0; }

		//("v-align" "=" v_align=VerticalAlignment)?
		public Group getGroup_2_4() { return cGroup_2_4; }

		//"v-align"
		public Keyword getVAlignKeyword_2_4_0() { return cVAlignKeyword_2_4_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_4_1() { return cEqualsSignKeyword_2_4_1; }

		//v_align=VerticalAlignment
		public Assignment getV_alignAssignment_2_4_2() { return cV_alignAssignment_2_4_2; }

		//VerticalAlignment
		public RuleCall getV_alignVerticalAlignmentEnumRuleCall_2_4_2_0() { return cV_alignVerticalAlignmentEnumRuleCall_2_4_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_5() { return cRightParenthesisKeyword_2_5; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//nestedGroups+=GroupElement+ | leafGroups+=ElementBody+
		public Alternatives getAlternatives_4() { return cAlternatives_4; }

		//nestedGroups+=GroupElement+
		public Assignment getNestedGroupsAssignment_4_0() { return cNestedGroupsAssignment_4_0; }

		//GroupElement
		public RuleCall getNestedGroupsGroupElementParserRuleCall_4_0_0() { return cNestedGroupsGroupElementParserRuleCall_4_0_0; }

		//leafGroups+=ElementBody+
		public Assignment getLeafGroupsAssignment_4_1() { return cLeafGroupsAssignment_4_1; }

		//ElementBody
		public RuleCall getLeafGroupsElementBodyParserRuleCall_4_1_0() { return cLeafGroupsElementBodyParserRuleCall_4_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class CountdownTimerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CountdownTimer");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCountdownTimerKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cObservedAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cObservedObserveKeyword_2_0 = (Keyword)cObservedAssignment_2.eContents().get(0);
		private final Assignment cEndTimeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cEndTimeExpressionParserRuleCall_3_0 = (RuleCall)cEndTimeAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cOnEndKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Keyword cEqualsSignKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Assignment cOnEndAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cOnEndExpressionParserRuleCall_4_2_0 = (RuleCall)cOnEndAssignment_4_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//CountdownTimer:
		//	"countdownTimer" "(" observed?="observe"? endTime=Expression ("onEnd" "=" onEnd=Expression)? ")";
		public ParserRule getRule() { return rule; }

		//"countdownTimer" "(" observed?="observe"? endTime=Expression ("onEnd" "=" onEnd=Expression)? ")"
		public Group getGroup() { return cGroup; }

		//"countdownTimer"
		public Keyword getCountdownTimerKeyword_0() { return cCountdownTimerKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//observed?="observe"?
		public Assignment getObservedAssignment_2() { return cObservedAssignment_2; }

		//"observe"
		public Keyword getObservedObserveKeyword_2_0() { return cObservedObserveKeyword_2_0; }

		//endTime=Expression
		public Assignment getEndTimeAssignment_3() { return cEndTimeAssignment_3; }

		//Expression
		public RuleCall getEndTimeExpressionParserRuleCall_3_0() { return cEndTimeExpressionParserRuleCall_3_0; }

		//("onEnd" "=" onEnd=Expression)?
		public Group getGroup_4() { return cGroup_4; }

		//"onEnd"
		public Keyword getOnEndKeyword_4_0() { return cOnEndKeyword_4_0; }

		//"="
		public Keyword getEqualsSignKeyword_4_1() { return cEqualsSignKeyword_4_1; }

		//onEnd=Expression
		public Assignment getOnEndAssignment_4_2() { return cOnEndAssignment_4_2; }

		//Expression
		public RuleCall getOnEndExpressionParserRuleCall_4_2_0() { return cOnEndExpressionParserRuleCall_4_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class ObserveElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ObserveElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cObserveKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cObserveExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cObserveExprExpressionParserRuleCall_1_0 = (RuleCall)cObserveExprAssignment_1.eContents().get(0);
		private final Assignment cStatementBlockAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementBlockStatementBlockParserRuleCall_2_0 = (RuleCall)cStatementBlockAssignment_2.eContents().get(0);
		
		/// *
		//	 * validation:
		//	 *		1-  bindSite must be a proper target/valid left-hand side iff bound		[√]
		//	 * 		2-  onEnd.type == CallbackExpression iff onEnd != null					[√]
		//	 * / ObserveElement:
		//	"observe" observeExpr=Expression statementBlock=StatementBlock;
		public ParserRule getRule() { return rule; }

		//"observe" observeExpr=Expression statementBlock=StatementBlock
		public Group getGroup() { return cGroup; }

		//"observe"
		public Keyword getObserveKeyword_0() { return cObserveKeyword_0; }

		//observeExpr=Expression
		public Assignment getObserveExprAssignment_1() { return cObserveExprAssignment_1; }

		//Expression
		public RuleCall getObserveExprExpressionParserRuleCall_1_0() { return cObserveExprExpressionParserRuleCall_1_0; }

		//statementBlock=StatementBlock
		public Assignment getStatementBlockAssignment_2() { return cStatementBlockAssignment_2; }

		//StatementBlock
		public RuleCall getStatementBlockStatementBlockParserRuleCall_2_0() { return cStatementBlockStatementBlockParserRuleCall_2_0; }
	}

	public class CalendarElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CalendarElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCalendarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDateAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDateExpressionParserRuleCall_2_0 = (RuleCall)cDateAssignment_2.eContents().get(0);
		private final UnorderedGroup cUnorderedGroup_3 = (UnorderedGroup)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cUnorderedGroup_3.eContents().get(0);
		private final Keyword cOnSelectKeyword_3_0_0 = (Keyword)cGroup_3_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_0_1 = (Keyword)cGroup_3_0.eContents().get(1);
		private final Assignment cOnSelectAssignment_3_0_2 = (Assignment)cGroup_3_0.eContents().get(2);
		private final RuleCall cOnSelectExpressionParserRuleCall_3_0_2_0 = (RuleCall)cOnSelectAssignment_3_0_2.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cUnorderedGroup_3.eContents().get(1);
		private final Keyword cAllowFromKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_1_1 = (Keyword)cGroup_3_1.eContents().get(1);
		private final Assignment cAllowFromAssignment_3_1_2 = (Assignment)cGroup_3_1.eContents().get(2);
		private final RuleCall cAllowFromExpressionParserRuleCall_3_1_2_0 = (RuleCall)cAllowFromAssignment_3_1_2.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cUnorderedGroup_3.eContents().get(2);
		private final Keyword cDateFormatKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_2_1 = (Keyword)cGroup_3_2.eContents().get(1);
		private final Assignment cDateFormatAssignment_3_2_2 = (Assignment)cGroup_3_2.eContents().get(2);
		private final RuleCall cDateFormatSTRINGTerminalRuleCall_3_2_2_0 = (RuleCall)cDateFormatAssignment_3_2_2.eContents().get(0);
		private final Group cGroup_3_3 = (Group)cUnorderedGroup_3.eContents().get(3);
		private final Keyword cCssForDaysKeyword_3_3_0 = (Keyword)cGroup_3_3.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_3_1 = (Keyword)cGroup_3_3.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_3_3_2 = (Keyword)cGroup_3_3.eContents().get(2);
		private final Keyword cDaysKeyword_3_3_3 = (Keyword)cGroup_3_3.eContents().get(3);
		private final Keyword cEqualsSignKeyword_3_3_4 = (Keyword)cGroup_3_3.eContents().get(4);
		private final Assignment cDaysAssignment_3_3_5 = (Assignment)cGroup_3_3.eContents().get(5);
		private final RuleCall cDaysExpressionParserRuleCall_3_3_5_0 = (RuleCall)cDaysAssignment_3_3_5.eContents().get(0);
		private final Keyword cCommaKeyword_3_3_6 = (Keyword)cGroup_3_3.eContents().get(6);
		private final Keyword cClassKeyword_3_3_7 = (Keyword)cGroup_3_3.eContents().get(7);
		private final Keyword cEqualsSignKeyword_3_3_8 = (Keyword)cGroup_3_3.eContents().get(8);
		private final Assignment cCssClassAssignment_3_3_9 = (Assignment)cGroup_3_3.eContents().get(9);
		private final RuleCall cCssClassSTRINGTerminalRuleCall_3_3_9_0 = (RuleCall)cCssClassAssignment_3_3_9.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_3_10 = (Keyword)cGroup_3_3.eContents().get(10);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// TODO  document precise semantics (and how is it different from a Binding e.g.)
		//CalendarElement:
		//	"calendar" "(" date=Expression (("onSelect" "=" onSelect=Expression)? & ("allowFrom" "=" allowFrom=Expression)? &
		//	("dateFormat" "=" dateFormat=STRING)? & ("cssForDays" "=" "(" "days" "=" days=Expression "," "class" "="
		//	cssClass=STRING ")")?) ")";
		public ParserRule getRule() { return rule; }

		//"calendar" "(" date=Expression (("onSelect" "=" onSelect=Expression)? & ("allowFrom" "=" allowFrom=Expression)? &
		//("dateFormat" "=" dateFormat=STRING)? & ("cssForDays" "=" "(" "days" "=" days=Expression "," "class" "="
		//cssClass=STRING ")")?) ")"
		public Group getGroup() { return cGroup; }

		//"calendar"
		public Keyword getCalendarKeyword_0() { return cCalendarKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//date=Expression
		public Assignment getDateAssignment_2() { return cDateAssignment_2; }

		//Expression
		public RuleCall getDateExpressionParserRuleCall_2_0() { return cDateExpressionParserRuleCall_2_0; }

		//("onSelect" "=" onSelect=Expression)? & ("allowFrom" "=" allowFrom=Expression)? & ("dateFormat" "=" dateFormat=STRING)?
		//& ("cssForDays" "=" "(" "days" "=" days=Expression "," "class" "=" cssClass=STRING ")")?
		public UnorderedGroup getUnorderedGroup_3() { return cUnorderedGroup_3; }

		//("onSelect" "=" onSelect=Expression)?
		public Group getGroup_3_0() { return cGroup_3_0; }

		//"onSelect"
		public Keyword getOnSelectKeyword_3_0_0() { return cOnSelectKeyword_3_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_0_1() { return cEqualsSignKeyword_3_0_1; }

		//onSelect=Expression
		public Assignment getOnSelectAssignment_3_0_2() { return cOnSelectAssignment_3_0_2; }

		//Expression
		public RuleCall getOnSelectExpressionParserRuleCall_3_0_2_0() { return cOnSelectExpressionParserRuleCall_3_0_2_0; }

		//("allowFrom" "=" allowFrom=Expression)?
		public Group getGroup_3_1() { return cGroup_3_1; }

		//"allowFrom"
		public Keyword getAllowFromKeyword_3_1_0() { return cAllowFromKeyword_3_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_1_1() { return cEqualsSignKeyword_3_1_1; }

		//allowFrom=Expression
		public Assignment getAllowFromAssignment_3_1_2() { return cAllowFromAssignment_3_1_2; }

		//Expression
		public RuleCall getAllowFromExpressionParserRuleCall_3_1_2_0() { return cAllowFromExpressionParserRuleCall_3_1_2_0; }

		//("dateFormat" "=" dateFormat=STRING)?
		public Group getGroup_3_2() { return cGroup_3_2; }

		//"dateFormat"
		public Keyword getDateFormatKeyword_3_2_0() { return cDateFormatKeyword_3_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_2_1() { return cEqualsSignKeyword_3_2_1; }

		//dateFormat=STRING
		public Assignment getDateFormatAssignment_3_2_2() { return cDateFormatAssignment_3_2_2; }

		//STRING
		public RuleCall getDateFormatSTRINGTerminalRuleCall_3_2_2_0() { return cDateFormatSTRINGTerminalRuleCall_3_2_2_0; }

		//("cssForDays" "=" "(" "days" "=" days=Expression "," "class" "=" cssClass=STRING ")")?
		public Group getGroup_3_3() { return cGroup_3_3; }

		//"cssForDays"
		public Keyword getCssForDaysKeyword_3_3_0() { return cCssForDaysKeyword_3_3_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_3_1() { return cEqualsSignKeyword_3_3_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_3_3_2() { return cLeftParenthesisKeyword_3_3_2; }

		//"days"
		public Keyword getDaysKeyword_3_3_3() { return cDaysKeyword_3_3_3; }

		//"="
		public Keyword getEqualsSignKeyword_3_3_4() { return cEqualsSignKeyword_3_3_4; }

		//days=Expression
		public Assignment getDaysAssignment_3_3_5() { return cDaysAssignment_3_3_5; }

		//Expression
		public RuleCall getDaysExpressionParserRuleCall_3_3_5_0() { return cDaysExpressionParserRuleCall_3_3_5_0; }

		//","
		public Keyword getCommaKeyword_3_3_6() { return cCommaKeyword_3_3_6; }

		//"class"
		public Keyword getClassKeyword_3_3_7() { return cClassKeyword_3_3_7; }

		//"="
		public Keyword getEqualsSignKeyword_3_3_8() { return cEqualsSignKeyword_3_3_8; }

		//cssClass=STRING
		public Assignment getCssClassAssignment_3_3_9() { return cCssClassAssignment_3_3_9; }

		//STRING
		public RuleCall getCssClassSTRINGTerminalRuleCall_3_3_9_0() { return cCssClassSTRINGTerminalRuleCall_3_3_9_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3_3_10() { return cRightParenthesisKeyword_3_3_10; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class TimeSlotListElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TimeSlotListElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTimeSlotListKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSlotsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSlotsExpressionParserRuleCall_2_0 = (RuleCall)cSlotsAssignment_2.eContents().get(0);
		private final UnorderedGroup cUnorderedGroup_3 = (UnorderedGroup)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cUnorderedGroup_3.eContents().get(0);
		private final Keyword cOnSelectKeyword_3_0_0 = (Keyword)cGroup_3_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_0_1 = (Keyword)cGroup_3_0.eContents().get(1);
		private final Assignment cOnSelectAssignment_3_0_2 = (Assignment)cGroup_3_0.eContents().get(2);
		private final RuleCall cOnSelectExpressionParserRuleCall_3_0_2_0 = (RuleCall)cOnSelectAssignment_3_0_2.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cUnorderedGroup_3.eContents().get(1);
		private final Keyword cOnDeleteKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_1_1 = (Keyword)cGroup_3_1.eContents().get(1);
		private final Assignment cOnDeleteAssignment_3_1_2 = (Assignment)cGroup_3_1.eContents().get(2);
		private final RuleCall cOnDeleteExpressionParserRuleCall_3_1_2_0 = (RuleCall)cOnDeleteAssignment_3_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/// *
		//	 * validation:
		//	 * 		1-  onSelect.type == CallbackExpression		[√]
		//	 * 		2-	allowFrom.type.dateTyped				[√]
		//	 * 		3-	date.type.dateTyped						[ ]
		//	 * 		4-  date.lhs???		TODO
		//	 * 		5-	days.type.listTyped						[ ]
		//	 * 		6-	days.type.listItemType.dateTyped		[ ]
		//	 * / TimeSlotListElement:
		//	"timeSlotList" "(" slots=Expression (("onSelect" "=" onSelect=Expression)? & ("onDelete" "=" onDelete=Expression)?)
		//	")";
		public ParserRule getRule() { return rule; }

		//"timeSlotList" "(" slots=Expression (("onSelect" "=" onSelect=Expression)? & ("onDelete" "=" onDelete=Expression)?) ")"
		public Group getGroup() { return cGroup; }

		//"timeSlotList"
		public Keyword getTimeSlotListKeyword_0() { return cTimeSlotListKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//slots=Expression
		public Assignment getSlotsAssignment_2() { return cSlotsAssignment_2; }

		//Expression
		public RuleCall getSlotsExpressionParserRuleCall_2_0() { return cSlotsExpressionParserRuleCall_2_0; }

		//("onSelect" "=" onSelect=Expression)? & ("onDelete" "=" onDelete=Expression)?
		public UnorderedGroup getUnorderedGroup_3() { return cUnorderedGroup_3; }

		//("onSelect" "=" onSelect=Expression)?
		public Group getGroup_3_0() { return cGroup_3_0; }

		//"onSelect"
		public Keyword getOnSelectKeyword_3_0_0() { return cOnSelectKeyword_3_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_0_1() { return cEqualsSignKeyword_3_0_1; }

		//onSelect=Expression
		public Assignment getOnSelectAssignment_3_0_2() { return cOnSelectAssignment_3_0_2; }

		//Expression
		public RuleCall getOnSelectExpressionParserRuleCall_3_0_2_0() { return cOnSelectExpressionParserRuleCall_3_0_2_0; }

		//("onDelete" "=" onDelete=Expression)?
		public Group getGroup_3_1() { return cGroup_3_1; }

		//"onDelete"
		public Keyword getOnDeleteKeyword_3_1_0() { return cOnDeleteKeyword_3_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_1_1() { return cEqualsSignKeyword_3_1_1; }

		//onDelete=Expression
		public Assignment getOnDeleteAssignment_3_1_2() { return cOnDeleteAssignment_3_1_2; }

		//Expression
		public RuleCall getOnDeleteExpressionParserRuleCall_3_1_2_0() { return cOnDeleteExpressionParserRuleCall_3_1_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class SlotAddElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SlotAddElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSlotAddListKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cProductAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cProductExpressionParserRuleCall_2_0 = (RuleCall)cProductAssignment_2.eContents().get(0);
		private final Assignment cDayAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDayExpressionParserRuleCall_3_0 = (RuleCall)cDayAssignment_3.eContents().get(0);
		private final Assignment cSlotsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cSlotsExpressionParserRuleCall_4_0 = (RuleCall)cSlotsAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cLeftCurlyBracketKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cStartHourAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cStartHourExpressionParserRuleCall_5_1_0 = (RuleCall)cStartHourAssignment_5_1.eContents().get(0);
		private final Keyword cToKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Assignment cEndHourAssignment_5_3 = (Assignment)cGroup_5.eContents().get(3);
		private final RuleCall cEndHourExpressionParserRuleCall_5_3_0 = (RuleCall)cEndHourAssignment_5_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5_4 = (Keyword)cGroup_5.eContents().get(4);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		/// * validation:
		//	 * 		1-	slots.type = [Slot]						[ ]
		//	 * / SlotAddElement:
		//	"slotAddList" "(" product=Expression day=Expression slots=Expression ("{" startHour=Expression "to" endHour=Expression
		//	"}")? ")";
		public ParserRule getRule() { return rule; }

		//"slotAddList" "(" product=Expression day=Expression slots=Expression ("{" startHour=Expression "to" endHour=Expression
		//"}")? ")"
		public Group getGroup() { return cGroup; }

		//"slotAddList"
		public Keyword getSlotAddListKeyword_0() { return cSlotAddListKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//product=Expression
		public Assignment getProductAssignment_2() { return cProductAssignment_2; }

		//Expression
		public RuleCall getProductExpressionParserRuleCall_2_0() { return cProductExpressionParserRuleCall_2_0; }

		//day=Expression
		public Assignment getDayAssignment_3() { return cDayAssignment_3; }

		//Expression
		public RuleCall getDayExpressionParserRuleCall_3_0() { return cDayExpressionParserRuleCall_3_0; }

		//slots=Expression
		public Assignment getSlotsAssignment_4() { return cSlotsAssignment_4; }

		//Expression
		public RuleCall getSlotsExpressionParserRuleCall_4_0() { return cSlotsExpressionParserRuleCall_4_0; }

		//("{" startHour=Expression "to" endHour=Expression "}")?
		public Group getGroup_5() { return cGroup_5; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_5_0() { return cLeftCurlyBracketKeyword_5_0; }

		//startHour=Expression
		public Assignment getStartHourAssignment_5_1() { return cStartHourAssignment_5_1; }

		//Expression
		public RuleCall getStartHourExpressionParserRuleCall_5_1_0() { return cStartHourExpressionParserRuleCall_5_1_0; }

		//"to"
		public Keyword getToKeyword_5_2() { return cToKeyword_5_2; }

		//endHour=Expression
		public Assignment getEndHourAssignment_5_3() { return cEndHourAssignment_5_3; }

		//Expression
		public RuleCall getEndHourExpressionParserRuleCall_5_3_0() { return cEndHourExpressionParserRuleCall_5_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5_4() { return cRightCurlyBracketKeyword_5_4; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
	}

	public class WhenElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhenElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExpressionParserRuleCall_2_0 = (RuleCall)cConditionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBodyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBodyElementBodyParserRuleCall_4_0 = (RuleCall)cBodyAssignment_4.eContents().get(0);
		
		//WhenElement:
		//	"when" "(" condition=Expression ")" body=ElementBody;
		public ParserRule getRule() { return rule; }

		//"when" "(" condition=Expression ")" body=ElementBody
		public Group getGroup() { return cGroup; }

		//"when"
		public Keyword getWhenKeyword_0() { return cWhenKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//condition=Expression
		public Assignment getConditionAssignment_2() { return cConditionAssignment_2; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_2_0() { return cConditionExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//body=ElementBody
		public Assignment getBodyAssignment_4() { return cBodyAssignment_4; }

		//ElementBody
		public RuleCall getBodyElementBodyParserRuleCall_4_0() { return cBodyElementBodyParserRuleCall_4_0; }
	}

	public class ImageElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ImageElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final UnorderedGroup cUnorderedGroup_2 = (UnorderedGroup)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cUnorderedGroup_2.eContents().get(0);
		private final Assignment cObservedAssignment_2_0_0 = (Assignment)cGroup_2_0.eContents().get(0);
		private final Keyword cObservedObserveKeyword_2_0_0_0 = (Keyword)cObservedAssignment_2_0_0.eContents().get(0);
		private final Assignment cSourceUrlAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cSourceUrlExpressionParserRuleCall_2_0_1_0 = (RuleCall)cSourceUrlAssignment_2_0_1.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cUnorderedGroup_2.eContents().get(1);
		private final Keyword cWidthKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_1_1 = (Keyword)cGroup_2_1.eContents().get(1);
		private final Assignment cWidthAssignment_2_1_2 = (Assignment)cGroup_2_1.eContents().get(2);
		private final RuleCall cWidthExpressionParserRuleCall_2_1_2_0 = (RuleCall)cWidthAssignment_2_1_2.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cUnorderedGroup_2.eContents().get(2);
		private final Keyword cHeightKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_2_1 = (Keyword)cGroup_2_2.eContents().get(1);
		private final Assignment cHeightAssignment_2_2_2 = (Assignment)cGroup_2_2.eContents().get(2);
		private final RuleCall cHeightExpressionParserRuleCall_2_2_2_0 = (RuleCall)cHeightAssignment_2_2_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// validation: condition.type.booleanTyped			[√]
		//ImageElement:
		//	"image" "(" (observed?="observe"? sourceUrl=Expression & ("width" "=" width=Expression)? & ("height" "="
		//	height=Expression)?) ")";
		public ParserRule getRule() { return rule; }

		//"image" "(" (observed?="observe"? sourceUrl=Expression & ("width" "=" width=Expression)? & ("height" "="
		//height=Expression)?) ")"
		public Group getGroup() { return cGroup; }

		//"image"
		public Keyword getImageKeyword_0() { return cImageKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//observed?="observe"? sourceUrl=Expression & ("width" "=" width=Expression)? & ("height" "=" height=Expression)?
		public UnorderedGroup getUnorderedGroup_2() { return cUnorderedGroup_2; }

		//observed?="observe"? sourceUrl=Expression
		public Group getGroup_2_0() { return cGroup_2_0; }

		//observed?="observe"?
		public Assignment getObservedAssignment_2_0_0() { return cObservedAssignment_2_0_0; }

		//"observe"
		public Keyword getObservedObserveKeyword_2_0_0_0() { return cObservedObserveKeyword_2_0_0_0; }

		//sourceUrl=Expression
		public Assignment getSourceUrlAssignment_2_0_1() { return cSourceUrlAssignment_2_0_1; }

		//Expression
		public RuleCall getSourceUrlExpressionParserRuleCall_2_0_1_0() { return cSourceUrlExpressionParserRuleCall_2_0_1_0; }

		//("width" "=" width=Expression)?
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"width"
		public Keyword getWidthKeyword_2_1_0() { return cWidthKeyword_2_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_1_1() { return cEqualsSignKeyword_2_1_1; }

		//width=Expression
		public Assignment getWidthAssignment_2_1_2() { return cWidthAssignment_2_1_2; }

		//Expression
		public RuleCall getWidthExpressionParserRuleCall_2_1_2_0() { return cWidthExpressionParserRuleCall_2_1_2_0; }

		//("height" "=" height=Expression)?
		public Group getGroup_2_2() { return cGroup_2_2; }

		//"height"
		public Keyword getHeightKeyword_2_2_0() { return cHeightKeyword_2_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_2_1() { return cEqualsSignKeyword_2_2_1; }

		//height=Expression
		public Assignment getHeightAssignment_2_2_2() { return cHeightAssignment_2_2_2; }

		//Expression
		public RuleCall getHeightExpressionParserRuleCall_2_2_2_0() { return cHeightExpressionParserRuleCall_2_2_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class FrameElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FrameElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIframeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSourceUrlAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSourceUrlExpressionParserRuleCall_2_0 = (RuleCall)cSourceUrlAssignment_2.eContents().get(0);
		private final UnorderedGroup cUnorderedGroup_3 = (UnorderedGroup)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cUnorderedGroup_3.eContents().get(0);
		private final Keyword cWidthKeyword_3_0_0 = (Keyword)cGroup_3_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_0_1 = (Keyword)cGroup_3_0.eContents().get(1);
		private final Assignment cWidthAssignment_3_0_2 = (Assignment)cGroup_3_0.eContents().get(2);
		private final RuleCall cWidthExpressionParserRuleCall_3_0_2_0 = (RuleCall)cWidthAssignment_3_0_2.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cUnorderedGroup_3.eContents().get(1);
		private final Keyword cHeightKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_1_1 = (Keyword)cGroup_3_1.eContents().get(1);
		private final Assignment cHeightAssignment_3_1_2 = (Assignment)cGroup_3_1.eContents().get(2);
		private final RuleCall cHeightExpressionParserRuleCall_3_1_2_0 = (RuleCall)cHeightAssignment_3_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/// * 
		//	 * validation: source.type.stringTyped				[√]
		//	 * width and height should be Integer typed.		[ ]
		//	 * / // (not called 'IFrameElement' because of possible confusion with an interface)
		//FrameElement:
		//	"iframe" "(" sourceUrl=Expression (("width" "=" width=Expression)? & ("height" "=" height=Expression)?) ")";
		public ParserRule getRule() { return rule; }

		//"iframe" "(" sourceUrl=Expression (("width" "=" width=Expression)? & ("height" "=" height=Expression)?) ")"
		public Group getGroup() { return cGroup; }

		//"iframe"
		public Keyword getIframeKeyword_0() { return cIframeKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//sourceUrl=Expression
		public Assignment getSourceUrlAssignment_2() { return cSourceUrlAssignment_2; }

		//Expression
		public RuleCall getSourceUrlExpressionParserRuleCall_2_0() { return cSourceUrlExpressionParserRuleCall_2_0; }

		//("width" "=" width=Expression)? & ("height" "=" height=Expression)?
		public UnorderedGroup getUnorderedGroup_3() { return cUnorderedGroup_3; }

		//("width" "=" width=Expression)?
		public Group getGroup_3_0() { return cGroup_3_0; }

		//"width"
		public Keyword getWidthKeyword_3_0_0() { return cWidthKeyword_3_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_0_1() { return cEqualsSignKeyword_3_0_1; }

		//width=Expression
		public Assignment getWidthAssignment_3_0_2() { return cWidthAssignment_3_0_2; }

		//Expression
		public RuleCall getWidthExpressionParserRuleCall_3_0_2_0() { return cWidthExpressionParserRuleCall_3_0_2_0; }

		//("height" "=" height=Expression)?
		public Group getGroup_3_1() { return cGroup_3_1; }

		//"height"
		public Keyword getHeightKeyword_3_1_0() { return cHeightKeyword_3_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_1_1() { return cEqualsSignKeyword_3_1_1; }

		//height=Expression
		public Assignment getHeightAssignment_3_1_2() { return cHeightAssignment_3_1_2; }

		//Expression
		public RuleCall getHeightExpressionParserRuleCall_3_1_2_0() { return cHeightExpressionParserRuleCall_3_1_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class LineBreakElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LineBreakElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLineBreakElementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLineBreakKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		/// *
		//	 * validation:
		//	 * 		1-  sourceUrl.type.stringTyped				[√]
		//	 * 		2-	{width, height}.type.integerTyped		[√]
		//	 * / // TODO  make source URL observable?
		//LineBreakElement:
		//	{LineBreakElement} "line-break";
		public ParserRule getRule() { return rule; }

		//{LineBreakElement} "line-break"
		public Group getGroup() { return cGroup; }

		//{LineBreakElement}
		public Action getLineBreakElementAction_0() { return cLineBreakElementAction_0; }

		//"line-break"
		public Keyword getLineBreakKeyword_1() { return cLineBreakKeyword_1; }
	}

	public class StatementBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StatementBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStatementBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementsStatementParserRuleCall_2_0 = (RuleCall)cStatementsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// *
		// * +------------+
		// * | statements |
		// * +------------+
		// * / StatementBlock:
		//	{StatementBlock} "{" statements+=Statement* "}";
		public ParserRule getRule() { return rule; }

		//{StatementBlock} "{" statements+=Statement* "}"
		public Group getGroup() { return cGroup; }

		//{StatementBlock}
		public Action getStatementBlockAction_0() { return cStatementBlockAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//statements+=Statement*
		public Assignment getStatementsAssignment_2() { return cStatementsAssignment_2; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_2_0() { return cStatementsStatementParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNonExitingStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExitingStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		//	 * validation:	warning if #statements == 0			[√]
		//	 * 
		//	 * A StatementBlock is contained by the following features:
		//	 * 		MethodDefinition.statementBlock
		//	 * 		CallbackExpression.statementBlock
		//	 * 		IfStatement.thenBlock
		//	 * 		IfStatement.elseBlock
		//	 * / // (synthetic type)
		//Statement:
		//	NonExitingStatement | ExitingStatement;
		public ParserRule getRule() { return rule; }

		//NonExitingStatement | ExitingStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//NonExitingStatement
		public RuleCall getNonExitingStatementParserRuleCall_0() { return cNonExitingStatementParserRuleCall_0; }

		//ExitingStatement
		public RuleCall getExitingStatementParserRuleCall_1() { return cExitingStatementParserRuleCall_1; }
	}

	public class ExitingStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExitingStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cGotoScreenStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cGotoModuleStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// A Statement is always contained in a StatementBlock.
		//ExitingStatement:
		//	GotoScreenStatement | GotoModuleStatement;
		public ParserRule getRule() { return rule; }

		//GotoScreenStatement | GotoModuleStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//GotoScreenStatement
		public RuleCall getGotoScreenStatementParserRuleCall_0() { return cGotoScreenStatementParserRuleCall_0; }

		//GotoModuleStatement
		public RuleCall getGotoModuleStatementParserRuleCall_1() { return cGotoModuleStatementParserRuleCall_1; }
	}

	public class NonExitingStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NonExitingStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAssignmentOrExpressionStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cShowModalStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExitModalStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIfStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cLocalValueDeclarationStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cListRemoveStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cForStatementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//NonExitingStatement:
		//	AssignmentOrExpressionStatement | ShowModalStatement | ExitModalStatement | IfStatement |
		//	LocalValueDeclarationStatement | ListRemoveStatement | ForStatement;
		public ParserRule getRule() { return rule; }

		//AssignmentOrExpressionStatement | ShowModalStatement | ExitModalStatement | IfStatement | LocalValueDeclarationStatement
		//| ListRemoveStatement | ForStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//AssignmentOrExpressionStatement
		public RuleCall getAssignmentOrExpressionStatementParserRuleCall_0() { return cAssignmentOrExpressionStatementParserRuleCall_0; }

		//ShowModalStatement
		public RuleCall getShowModalStatementParserRuleCall_1() { return cShowModalStatementParserRuleCall_1; }

		//ExitModalStatement
		public RuleCall getExitModalStatementParserRuleCall_2() { return cExitModalStatementParserRuleCall_2; }

		//IfStatement
		public RuleCall getIfStatementParserRuleCall_3() { return cIfStatementParserRuleCall_3; }

		//LocalValueDeclarationStatement
		public RuleCall getLocalValueDeclarationStatementParserRuleCall_4() { return cLocalValueDeclarationStatementParserRuleCall_4; }

		//ListRemoveStatement
		public RuleCall getListRemoveStatementParserRuleCall_5() { return cListRemoveStatementParserRuleCall_5; }

		//ForStatement
		public RuleCall getForStatementParserRuleCall_6() { return cForStatementParserRuleCall_6; }
	}

	public class ForStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cIndexVariableAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cIndexVariableListVariableParserRuleCall_3_0 = (RuleCall)cIndexVariableAssignment_3.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValueVariableAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValueVariableListVariableParserRuleCall_5_0 = (RuleCall)cValueVariableAssignment_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cInKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cListExpressionAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cListExpressionExpressionParserRuleCall_8_0 = (RuleCall)cListExpressionAssignment_8.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Assignment cThenBlockAssignment_10 = (Assignment)cGroup.eContents().get(10);
		private final RuleCall cThenBlockStatementBlockParserRuleCall_10_0 = (RuleCall)cThenBlockAssignment_10.eContents().get(0);
		
		//ForStatement:
		//	"for" "(" "(" indexVariable=ListVariable "->" valueVariable=ListVariable ")" "in" listExpression=Expression ")"
		//	thenBlock=StatementBlock;
		public ParserRule getRule() { return rule; }

		//"for" "(" "(" indexVariable=ListVariable "->" valueVariable=ListVariable ")" "in" listExpression=Expression ")"
		//thenBlock=StatementBlock
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//indexVariable=ListVariable
		public Assignment getIndexVariableAssignment_3() { return cIndexVariableAssignment_3; }

		//ListVariable
		public RuleCall getIndexVariableListVariableParserRuleCall_3_0() { return cIndexVariableListVariableParserRuleCall_3_0; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_4() { return cHyphenMinusGreaterThanSignKeyword_4; }

		//valueVariable=ListVariable
		public Assignment getValueVariableAssignment_5() { return cValueVariableAssignment_5; }

		//ListVariable
		public RuleCall getValueVariableListVariableParserRuleCall_5_0() { return cValueVariableListVariableParserRuleCall_5_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//"in"
		public Keyword getInKeyword_7() { return cInKeyword_7; }

		//listExpression=Expression
		public Assignment getListExpressionAssignment_8() { return cListExpressionAssignment_8; }

		//Expression
		public RuleCall getListExpressionExpressionParserRuleCall_8_0() { return cListExpressionExpressionParserRuleCall_8_0; }

		//")"
		public Keyword getRightParenthesisKeyword_9() { return cRightParenthesisKeyword_9; }

		//thenBlock=StatementBlock
		public Assignment getThenBlockAssignment_10() { return cThenBlockAssignment_10; }

		//StatementBlock
		public RuleCall getThenBlockStatementBlockParserRuleCall_10_0() { return cThenBlockStatementBlockParserRuleCall_10_0; }
	}

	public class ListRemoveStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ListRemoveStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRemoveKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cFromKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cListExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cListExprExpressionParserRuleCall_2_0 = (RuleCall)cListExprAssignment_2.eContents().get(0);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cAlternatives_3.eContents().get(0);
		private final Keyword cWhereKeyword_3_0_0 = (Keyword)cGroup_3_0.eContents().get(0);
		private final Assignment cFeatureAssignment_3_0_1 = (Assignment)cGroup_3_0.eContents().get(1);
		private final CrossReference cFeatureFeatureCrossReference_3_0_1_0 = (CrossReference)cFeatureAssignment_3_0_1.eContents().get(0);
		private final RuleCall cFeatureFeatureIDTerminalRuleCall_3_0_1_0_1 = (RuleCall)cFeatureFeatureCrossReference_3_0_1_0.eContents().get(1);
		private final Keyword cEqualsSignEqualsSignKeyword_3_0_2 = (Keyword)cGroup_3_0.eContents().get(2);
		private final Assignment cValueExprAssignment_3_0_3 = (Assignment)cGroup_3_0.eContents().get(3);
		private final RuleCall cValueExprExpressionParserRuleCall_3_0_3_0 = (RuleCall)cValueExprAssignment_3_0_3.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cAlternatives_3.eContents().get(1);
		private final Keyword cAtKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cIndexVariableAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cIndexVariableExpressionParserRuleCall_3_1_1_0 = (RuleCall)cIndexVariableAssignment_3_1_1.eContents().get(0);
		
		//ListRemoveStatement:
		//	"remove" "from" listExpr=Expression ("where" feature=[struct::Feature] "==" valueExpr=Expression | "at"
		//	indexVariable=Expression);
		public ParserRule getRule() { return rule; }

		//"remove" "from" listExpr=Expression ("where" feature=[struct::Feature] "==" valueExpr=Expression | "at"
		//indexVariable=Expression)
		public Group getGroup() { return cGroup; }

		//"remove"
		public Keyword getRemoveKeyword_0() { return cRemoveKeyword_0; }

		//"from"
		public Keyword getFromKeyword_1() { return cFromKeyword_1; }

		//listExpr=Expression
		public Assignment getListExprAssignment_2() { return cListExprAssignment_2; }

		//Expression
		public RuleCall getListExprExpressionParserRuleCall_2_0() { return cListExprExpressionParserRuleCall_2_0; }

		//"where" feature=[struct::Feature] "==" valueExpr=Expression | "at" indexVariable=Expression
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//"where" feature=[struct::Feature] "==" valueExpr=Expression
		public Group getGroup_3_0() { return cGroup_3_0; }

		//"where"
		public Keyword getWhereKeyword_3_0_0() { return cWhereKeyword_3_0_0; }

		//feature=[struct::Feature]
		public Assignment getFeatureAssignment_3_0_1() { return cFeatureAssignment_3_0_1; }

		//[struct::Feature]
		public CrossReference getFeatureFeatureCrossReference_3_0_1_0() { return cFeatureFeatureCrossReference_3_0_1_0; }

		//ID
		public RuleCall getFeatureFeatureIDTerminalRuleCall_3_0_1_0_1() { return cFeatureFeatureIDTerminalRuleCall_3_0_1_0_1; }

		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_3_0_2() { return cEqualsSignEqualsSignKeyword_3_0_2; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_3_0_3() { return cValueExprAssignment_3_0_3; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_3_0_3_0() { return cValueExprExpressionParserRuleCall_3_0_3_0; }

		//"at" indexVariable=Expression
		public Group getGroup_3_1() { return cGroup_3_1; }

		//"at"
		public Keyword getAtKeyword_3_1_0() { return cAtKeyword_3_1_0; }

		//indexVariable=Expression
		public Assignment getIndexVariableAssignment_3_1_1() { return cIndexVariableAssignment_3_1_1; }

		//Expression
		public RuleCall getIndexVariableExpressionParserRuleCall_3_1_1_0() { return cIndexVariableExpressionParserRuleCall_3_1_1_0; }
	}

	public class AssignmentOrExpressionStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentOrExpressionStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsExpressionParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cOperatorAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cOperatorAssignmentOperatorEnumRuleCall_1_0_0 = (RuleCall)cOperatorAssignment_1_0.eContents().get(0);
		private final Assignment cRhsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRhsExpressionParserRuleCall_1_1_0 = (RuleCall)cRhsAssignment_1_1.eContents().get(0);
		
		/// *
		//	 * scoping: feature in listExpr.type.listItemType.structure.features			[√]
		//	 * validation:
		//	 * 		1-  listExpr.type = [Structure]											[√]
		//	 * 		2-  if feature != null: feature.type.isAssignableFrom(valueExpr.type)	[√]
		//	 * / AssignmentOrExpressionStatement:
		//	lhs=Expression (operator=AssignmentOperator rhs=Expression)?;
		public ParserRule getRule() { return rule; }

		//lhs=Expression (operator=AssignmentOperator rhs=Expression)?
		public Group getGroup() { return cGroup; }

		//lhs=Expression
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//Expression
		public RuleCall getLhsExpressionParserRuleCall_0_0() { return cLhsExpressionParserRuleCall_0_0; }

		//(operator=AssignmentOperator rhs=Expression)?
		public Group getGroup_1() { return cGroup_1; }

		//operator=AssignmentOperator
		public Assignment getOperatorAssignment_1_0() { return cOperatorAssignment_1_0; }

		//AssignmentOperator
		public RuleCall getOperatorAssignmentOperatorEnumRuleCall_1_0_0() { return cOperatorAssignmentOperatorEnumRuleCall_1_0_0; }

		//rhs=Expression
		public Assignment getRhsAssignment_1_1() { return cRhsAssignment_1_1; }

		//Expression
		public RuleCall getRhsExpressionParserRuleCall_1_1_0() { return cRhsExpressionParserRuleCall_1_1_0; }
	}

	public class ShowModalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ShowModalStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cShowModalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cViewableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cViewableViewableCrossReference_1_0 = (CrossReference)cViewableAssignment_1.eContents().get(0);
		private final RuleCall cViewableViewableIDTerminalRuleCall_1_0_1 = (RuleCall)cViewableViewableCrossReference_1_0.eContents().get(1);
		private final Assignment cArgumentListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgumentListArgumentListParserRuleCall_2_0 = (RuleCall)cArgumentListAssignment_2.eContents().get(0);
		private final Assignment cPersistentAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cPersistentPersistentKeyword_3_0 = (Keyword)cPersistentAssignment_3.eContents().get(0);
		
		//ShowModalStatement:
		//	"show-modal" viewable=[Viewable] argumentList=ArgumentList persistent?="persistent"?;
		public ParserRule getRule() { return rule; }

		//"show-modal" viewable=[Viewable] argumentList=ArgumentList persistent?="persistent"?
		public Group getGroup() { return cGroup; }

		//"show-modal"
		public Keyword getShowModalKeyword_0() { return cShowModalKeyword_0; }

		//viewable=[Viewable]
		public Assignment getViewableAssignment_1() { return cViewableAssignment_1; }

		//[Viewable]
		public CrossReference getViewableViewableCrossReference_1_0() { return cViewableViewableCrossReference_1_0; }

		//ID
		public RuleCall getViewableViewableIDTerminalRuleCall_1_0_1() { return cViewableViewableIDTerminalRuleCall_1_0_1; }

		//argumentList=ArgumentList
		public Assignment getArgumentListAssignment_2() { return cArgumentListAssignment_2; }

		//ArgumentList
		public RuleCall getArgumentListArgumentListParserRuleCall_2_0() { return cArgumentListArgumentListParserRuleCall_2_0; }

		//persistent?="persistent"?
		public Assignment getPersistentAssignment_3() { return cPersistentAssignment_3; }

		//"persistent"
		public Keyword getPersistentPersistentKeyword_3_0() { return cPersistentPersistentKeyword_3_0; }
	}

	public class ExitModalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExitModalStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExitModalStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cExitModalKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//ExitModalStatement:
		//	{ExitModalStatement} "exit-modal";
		public ParserRule getRule() { return rule; }

		//{ExitModalStatement} "exit-modal"
		public Group getGroup() { return cGroup; }

		//{ExitModalStatement}
		public Action getExitModalStatementAction_0() { return cExitModalStatementAction_0; }

		//"exit-modal"
		public Keyword getExitModalKeyword_1() { return cExitModalKeyword_1; }
	}

	public class GotoScreenStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GotoScreenStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cGotoKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cGotoScreenKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Assignment cViewableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cViewableViewableCrossReference_1_0 = (CrossReference)cViewableAssignment_1.eContents().get(0);
		private final RuleCall cViewableViewableIDTerminalRuleCall_1_0_1 = (RuleCall)cViewableViewableCrossReference_1_0.eContents().get(1);
		private final Assignment cArgumentListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgumentListArgumentListParserRuleCall_2_0 = (RuleCall)cArgumentListAssignment_2.eContents().get(0);
		
		//GotoScreenStatement:
		//	("goto" | "goto-screen") viewable=[Viewable] => argumentList=ArgumentList;
		public ParserRule getRule() { return rule; }

		//("goto" | "goto-screen") viewable=[Viewable] => argumentList=ArgumentList
		public Group getGroup() { return cGroup; }

		//"goto" | "goto-screen"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"goto"
		public Keyword getGotoKeyword_0_0() { return cGotoKeyword_0_0; }

		//"goto-screen"
		public Keyword getGotoScreenKeyword_0_1() { return cGotoScreenKeyword_0_1; }

		//viewable=[Viewable]
		public Assignment getViewableAssignment_1() { return cViewableAssignment_1; }

		//[Viewable]
		public CrossReference getViewableViewableCrossReference_1_0() { return cViewableViewableCrossReference_1_0; }

		//ID
		public RuleCall getViewableViewableIDTerminalRuleCall_1_0_1() { return cViewableViewableIDTerminalRuleCall_1_0_1; }

		//=> argumentList=ArgumentList
		public Assignment getArgumentListAssignment_2() { return cArgumentListAssignment_2; }

		//ArgumentList
		public RuleCall getArgumentListArgumentListParserRuleCall_2_0() { return cArgumentListArgumentListParserRuleCall_2_0; }
	}

	public class GotoModuleStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GotoModuleStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGotoModuleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTargetModuleAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTargetModuleUiModuleCrossReference_1_0 = (CrossReference)cTargetModuleAssignment_1.eContents().get(0);
		private final RuleCall cTargetModuleUiModuleIDTerminalRuleCall_1_0_1 = (RuleCall)cTargetModuleUiModuleCrossReference_1_0.eContents().get(1);
		private final Assignment cArgsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgsArgumentListParserRuleCall_2_0 = (RuleCall)cArgsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cAuthenticateAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final Keyword cAuthenticateAfterAuthenticationByKeyword_3_0_0 = (Keyword)cAuthenticateAssignment_3_0.eContents().get(0);
		private final Assignment cAuthOptionAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cAuthOptionAuthenticationDeclarationCrossReference_3_1_0 = (CrossReference)cAuthOptionAssignment_3_1.eContents().get(0);
		private final RuleCall cAuthOptionAuthenticationDeclarationIDTerminalRuleCall_3_1_0_1 = (RuleCall)cAuthOptionAuthenticationDeclarationCrossReference_3_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Assignment cPrincipalAssignment_3_3 = (Assignment)cGroup_3.eContents().get(3);
		private final RuleCall cPrincipalPrincipalArgumentParserRuleCall_3_3_0 = (RuleCall)cPrincipalAssignment_3_3.eContents().get(0);
		private final Keyword cCommaKeyword_3_4 = (Keyword)cGroup_3.eContents().get(4);
		private final Assignment cCredentialAssignment_3_5 = (Assignment)cGroup_3.eContents().get(5);
		private final RuleCall cCredentialCredentialArgumentParserRuleCall_3_5_0 = (RuleCall)cCredentialAssignment_3_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_6 = (Keyword)cGroup_3.eContents().get(6);
		private final Keyword cErrorKeyword_3_7 = (Keyword)cGroup_3.eContents().get(7);
		private final Assignment cErrorCallbackAssignment_3_8 = (Assignment)cGroup_3.eContents().get(8);
		private final RuleCall cErrorCallbackCallbackExpressionParserRuleCall_3_8_0 = (RuleCall)cErrorCallbackAssignment_3_8.eContents().get(0);
		
		//// scoping: viewable == all(Viewable)-in-this-resource.filter[screen]	[√]
		/// *
		//	 * Call syntax is now aligned with declaration syntax because '(..)' are required.
		//	 * / GotoModuleStatement:
		//	"goto-module" targetModule=[UiModule] args=ArgumentList / *
		//	 * (I'd rather use 'argumentList' instead 'args' but that triggers
		//	 * the duplicate feature validation of Xtext - whether that's incorrect or not.)
		//	 * / (authenticate?="after-authentication-by" authOption=[backend::AuthenticationDeclaration] "("
		//	principal=PrincipalArgument "," credential=CredentialArgument ")" "@error:" errorCallback=CallbackExpression)?;
		public ParserRule getRule() { return rule; }

		//"goto-module" targetModule=[UiModule] args=ArgumentList / *
		//	 * (I'd rather use 'argumentList' instead 'args' but that triggers
		//	 * the duplicate feature validation of Xtext - whether that's incorrect or not.)
		//	 * / (authenticate?="after-authentication-by" authOption=[backend::AuthenticationDeclaration] "("
		//principal=PrincipalArgument "," credential=CredentialArgument ")" "@error:" errorCallback=CallbackExpression)?
		public Group getGroup() { return cGroup; }

		//"goto-module"
		public Keyword getGotoModuleKeyword_0() { return cGotoModuleKeyword_0; }

		//targetModule=[UiModule]
		public Assignment getTargetModuleAssignment_1() { return cTargetModuleAssignment_1; }

		//[UiModule]
		public CrossReference getTargetModuleUiModuleCrossReference_1_0() { return cTargetModuleUiModuleCrossReference_1_0; }

		//ID
		public RuleCall getTargetModuleUiModuleIDTerminalRuleCall_1_0_1() { return cTargetModuleUiModuleIDTerminalRuleCall_1_0_1; }

		//args=ArgumentList
		public Assignment getArgsAssignment_2() { return cArgsAssignment_2; }

		//ArgumentList
		public RuleCall getArgsArgumentListParserRuleCall_2_0() { return cArgsArgumentListParserRuleCall_2_0; }

		//(authenticate?="after-authentication-by" authOption=[backend::AuthenticationDeclaration] "(" principal=PrincipalArgument
		//"," credential=CredentialArgument ")" "@error:" errorCallback=CallbackExpression)?
		public Group getGroup_3() { return cGroup_3; }

		//authenticate?="after-authentication-by"
		public Assignment getAuthenticateAssignment_3_0() { return cAuthenticateAssignment_3_0; }

		//"after-authentication-by"
		public Keyword getAuthenticateAfterAuthenticationByKeyword_3_0_0() { return cAuthenticateAfterAuthenticationByKeyword_3_0_0; }

		//authOption=[backend::AuthenticationDeclaration]
		public Assignment getAuthOptionAssignment_3_1() { return cAuthOptionAssignment_3_1; }

		//[backend::AuthenticationDeclaration]
		public CrossReference getAuthOptionAuthenticationDeclarationCrossReference_3_1_0() { return cAuthOptionAuthenticationDeclarationCrossReference_3_1_0; }

		//ID
		public RuleCall getAuthOptionAuthenticationDeclarationIDTerminalRuleCall_3_1_0_1() { return cAuthOptionAuthenticationDeclarationIDTerminalRuleCall_3_1_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_3_2() { return cLeftParenthesisKeyword_3_2; }

		//principal=PrincipalArgument
		public Assignment getPrincipalAssignment_3_3() { return cPrincipalAssignment_3_3; }

		//PrincipalArgument
		public RuleCall getPrincipalPrincipalArgumentParserRuleCall_3_3_0() { return cPrincipalPrincipalArgumentParserRuleCall_3_3_0; }

		//","
		public Keyword getCommaKeyword_3_4() { return cCommaKeyword_3_4; }

		//credential=CredentialArgument
		public Assignment getCredentialAssignment_3_5() { return cCredentialAssignment_3_5; }

		//CredentialArgument
		public RuleCall getCredentialCredentialArgumentParserRuleCall_3_5_0() { return cCredentialCredentialArgumentParserRuleCall_3_5_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3_6() { return cRightParenthesisKeyword_3_6; }

		//"@error:"
		public Keyword getErrorKeyword_3_7() { return cErrorKeyword_3_7; }

		//errorCallback=CallbackExpression
		public Assignment getErrorCallbackAssignment_3_8() { return cErrorCallbackAssignment_3_8; }

		//CallbackExpression
		public RuleCall getErrorCallbackCallbackExpressionParserRuleCall_3_8_0() { return cErrorCallbackCallbackExpressionParserRuleCall_3_8_0; }
	}

	public class PrincipalArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrincipalArgument");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPrincipalAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cPrincipalAuthenticationParameterCrossReference_0_0 = (CrossReference)cPrincipalAssignment_0.eContents().get(0);
		private final RuleCall cPrincipalAuthenticationParameterIDTerminalRuleCall_0_0_1 = (RuleCall)cPrincipalAuthenticationParameterCrossReference_0_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueExprExpressionParserRuleCall_2_0 = (RuleCall)cValueExprAssignment_2.eContents().get(0);
		
		/// *
		//	 * validation:
		//	 * 		1-  principals contains all principals of authOption.principals		[V]
		//	 * 		2-	credentials contains all credentials of authOption.credentials	[V]
		//	 * / PrincipalArgument:
		//	principal=[backend::AuthenticationParameter] "=" valueExpr=Expression;
		public ParserRule getRule() { return rule; }

		//principal=[backend::AuthenticationParameter] "=" valueExpr=Expression
		public Group getGroup() { return cGroup; }

		//principal=[backend::AuthenticationParameter]
		public Assignment getPrincipalAssignment_0() { return cPrincipalAssignment_0; }

		//[backend::AuthenticationParameter]
		public CrossReference getPrincipalAuthenticationParameterCrossReference_0_0() { return cPrincipalAuthenticationParameterCrossReference_0_0; }

		//ID
		public RuleCall getPrincipalAuthenticationParameterIDTerminalRuleCall_0_0_1() { return cPrincipalAuthenticationParameterIDTerminalRuleCall_0_0_1; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_2() { return cValueExprAssignment_2; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_2_0() { return cValueExprExpressionParserRuleCall_2_0; }
	}

	public class CredentialArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CredentialArgument");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCredentialAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cCredentialAuthenticationParameterCrossReference_0_0 = (CrossReference)cCredentialAssignment_0.eContents().get(0);
		private final RuleCall cCredentialAuthenticationParameterIDTerminalRuleCall_0_0_1 = (RuleCall)cCredentialAuthenticationParameterCrossReference_0_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueExprExpressionParserRuleCall_2_0 = (RuleCall)cValueExprAssignment_2.eContents().get(0);
		
		/// *
		//	 * validation:
		//	 * 		principal.type.isAssignableFrom(valueExpr.type)						[V]
		//	 * 
		//	 * scoping:
		//	 * 		principal in containerHaving(typeof GotoModuleStatement).authOption.principals
		//	 * / CredentialArgument:
		//	credential=[backend::AuthenticationParameter] "=" valueExpr=Expression;
		public ParserRule getRule() { return rule; }

		//credential=[backend::AuthenticationParameter] "=" valueExpr=Expression
		public Group getGroup() { return cGroup; }

		//credential=[backend::AuthenticationParameter]
		public Assignment getCredentialAssignment_0() { return cCredentialAssignment_0; }

		//[backend::AuthenticationParameter]
		public CrossReference getCredentialAuthenticationParameterCrossReference_0_0() { return cCredentialAuthenticationParameterCrossReference_0_0; }

		//ID
		public RuleCall getCredentialAuthenticationParameterIDTerminalRuleCall_0_0_1() { return cCredentialAuthenticationParameterIDTerminalRuleCall_0_0_1; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_2() { return cValueExprAssignment_2; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_2_0() { return cValueExprExpressionParserRuleCall_2_0; }
	}

	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExpressionParserRuleCall_2_0 = (RuleCall)cConditionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cThenBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cThenBlockStatementBlockParserRuleCall_4_0 = (RuleCall)cThenBlockAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cElseKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cElseBlockAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cElseBlockStatementBlockParserRuleCall_5_1_0 = (RuleCall)cElseBlockAssignment_5_1.eContents().get(0);
		
		/// *
		//	 * validation:
		//	 * 		credential.type.isAssignableFrom(valueExpr.type)					[V]
		//	 * 
		//	 * scoping:
		//	 * 		credential in containerHaving(typeof GotoModuleStatement).authOption.credentials
		//	 * / IfStatement:
		//	"if" "(" condition=Expression ")" thenBlock=StatementBlock ("else" elseBlock=StatementBlock)?;
		public ParserRule getRule() { return rule; }

		//"if" "(" condition=Expression ")" thenBlock=StatementBlock ("else" elseBlock=StatementBlock)?
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//condition=Expression
		public Assignment getConditionAssignment_2() { return cConditionAssignment_2; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_2_0() { return cConditionExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//thenBlock=StatementBlock
		public Assignment getThenBlockAssignment_4() { return cThenBlockAssignment_4; }

		//StatementBlock
		public RuleCall getThenBlockStatementBlockParserRuleCall_4_0() { return cThenBlockStatementBlockParserRuleCall_4_0; }

		//("else" elseBlock=StatementBlock)?
		public Group getGroup_5() { return cGroup_5; }

		//"else"
		public Keyword getElseKeyword_5_0() { return cElseKeyword_5_0; }

		//elseBlock=StatementBlock
		public Assignment getElseBlockAssignment_5_1() { return cElseBlockAssignment_5_1; }

		//StatementBlock
		public RuleCall getElseBlockStatementBlockParserRuleCall_5_1_0() { return cElseBlockStatementBlockParserRuleCall_5_1_0; }
	}

	public class LocalValueDeclarationStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalValueDeclarationStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cValKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cDeclaredTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cDeclaredTypeTypeLiteralParserRuleCall_2_1_0 = (RuleCall)cDeclaredTypeAssignment_2_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cValueExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cValueExprExpressionParserRuleCall_4_0 = (RuleCall)cValueExprAssignment_4.eContents().get(0);
		
		/// *
		//	 * validation:
		//	 *		1-  condition must be boolean-typed								[√]
		//	 * 		2-  thenBlock.type.isAssignableFrom(elseBlock.type)				[√]
		//	 * / LocalValueDeclarationStatement:
		//	"val" value=Value (":" declaredType=TypeLiteral)? "=" valueExpr=Expression;
		public ParserRule getRule() { return rule; }

		//=> "val" value=Value (":" declaredType=TypeLiteral)? "=" valueExpr=Expression
		public Group getGroup() { return cGroup; }

		//=> "val"
		public Keyword getValKeyword_0() { return cValKeyword_0; }

		//value=Value
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//Value
		public RuleCall getValueValueParserRuleCall_1_0() { return cValueValueParserRuleCall_1_0; }

		//(":" declaredType=TypeLiteral)?
		public Group getGroup_2() { return cGroup_2; }

		//":"
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }

		//declaredType=TypeLiteral
		public Assignment getDeclaredTypeAssignment_2_1() { return cDeclaredTypeAssignment_2_1; }

		//TypeLiteral
		public RuleCall getDeclaredTypeTypeLiteralParserRuleCall_2_1_0() { return cDeclaredTypeTypeLiteralParserRuleCall_2_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_4() { return cValueExprAssignment_4; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_4_0() { return cValueExprExpressionParserRuleCall_4_0; }
	}

	public class ViewableCallSiteElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ViewableCallSite");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cGotoScreenStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cComponentInvocationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTabDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cShowModalStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// (synthetic type)
		//ViewableCallSite:
		//	GotoScreenStatement | ComponentInvocation | TabDeclaration | ShowModalStatement;
		public ParserRule getRule() { return rule; }

		//GotoScreenStatement | ComponentInvocation | TabDeclaration | ShowModalStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//GotoScreenStatement
		public RuleCall getGotoScreenStatementParserRuleCall_0() { return cGotoScreenStatementParserRuleCall_0; }

		//ComponentInvocation
		public RuleCall getComponentInvocationParserRuleCall_1() { return cComponentInvocationParserRuleCall_1; }

		//TabDeclaration
		public RuleCall getTabDeclarationParserRuleCall_2() { return cTabDeclarationParserRuleCall_2; }

		//ShowModalStatement
		public RuleCall getShowModalStatementParserRuleCall_3() { return cShowModalStatementParserRuleCall_3; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cTernaryExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// validation: arguments are checked against viewable.parameters for unmapped and duplicately-mapped parameters		[√]
		/// *
		// * +-------------+
		// * | expressions |
		// * +-------------+
		// * / Expression:
		//	TernaryExpression;
		public ParserRule getRule() { return rule; }

		//TernaryExpression
		public RuleCall getTernaryExpressionParserRuleCall() { return cTernaryExpressionParserRuleCall; }
	}

	public class TernaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TernaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cTernaryExpressionGuardAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cQuestionMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cThenExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cThenExprOrExpressionParserRuleCall_1_2_0 = (RuleCall)cThenExprAssignment_1_2.eContents().get(0);
		private final Keyword cColonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cElseExprAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cElseExprOrExpressionParserRuleCall_1_4_0 = (RuleCall)cElseExprAssignment_1_4.eContents().get(0);
		
		//TernaryExpression returns Expression:
		//	OrExpression ({TernaryExpression.guard=current} "?" thenExpr=OrExpression ":" elseExpr=OrExpression)?;
		public ParserRule getRule() { return rule; }

		//OrExpression ({TernaryExpression.guard=current} "?" thenExpr=OrExpression ":" elseExpr=OrExpression)?
		public Group getGroup() { return cGroup; }

		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_0() { return cOrExpressionParserRuleCall_0; }

		//({TernaryExpression.guard=current} "?" thenExpr=OrExpression ":" elseExpr=OrExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{TernaryExpression.guard=current}
		public Action getTernaryExpressionGuardAction_1_0() { return cTernaryExpressionGuardAction_1_0; }

		//"?"
		public Keyword getQuestionMarkKeyword_1_1() { return cQuestionMarkKeyword_1_1; }

		//thenExpr=OrExpression
		public Assignment getThenExprAssignment_1_2() { return cThenExprAssignment_1_2; }

		//OrExpression
		public RuleCall getThenExprOrExpressionParserRuleCall_1_2_0() { return cThenExprOrExpressionParserRuleCall_1_2_0; }

		//":"
		public Keyword getColonKeyword_1_3() { return cColonKeyword_1_3; }

		//elseExpr=OrExpression
		public Assignment getElseExprAssignment_1_4() { return cElseExprAssignment_1_4; }

		//OrExpression
		public RuleCall getElseExprOrExpressionParserRuleCall_1_4_0() { return cElseExprOrExpressionParserRuleCall_1_4_0; }
	}

	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrExpressionLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		/// * 
		//	 * validation:
		//	 * 		1-  guard must be boolean-typed						[√]
		//	 * 		2-  thenExpr and elseExpr must be type-compatible	[√]
		//	 * / OrExpression returns Expression:
		//	AndExpression ({OrExpression.leftOperand=current} "||" rightOperand=AndExpression)* // left-associative infix binary operator
		//;
		public ParserRule getRule() { return rule; }

		//AndExpression ({OrExpression.leftOperand=current} "||" rightOperand=AndExpression)* // left-associative infix binary operator
		public Group getGroup() { return cGroup; }

		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }

		//({OrExpression.leftOperand=current} "||" rightOperand=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{OrExpression.leftOperand=current}
		public Action getOrExpressionLeftOperandAction_1_0() { return cOrExpressionLeftOperandAction_1_0; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }

		//rightOperand=AndExpression
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }

		//AndExpression
		public RuleCall getRightOperandAndExpressionParserRuleCall_1_2_0() { return cRightOperandAndExpressionParserRuleCall_1_2_0; }
	}

	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndExpressionLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandComparisonExpressionParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		//// validation: leftOperand, rightOperand are Boolean-typed	[√]
		//AndExpression returns Expression:
		//	ComparisonExpression ({AndExpression.leftOperand=current} "&&" rightOperand=ComparisonExpression)* // left-associative infix binary operator
		//;
		public ParserRule getRule() { return rule; }

		//ComparisonExpression ({AndExpression.leftOperand=current} "&&" rightOperand=ComparisonExpression)* // left-associative infix binary operator
		public Group getGroup() { return cGroup; }

		//ComparisonExpression
		public RuleCall getComparisonExpressionParserRuleCall_0() { return cComparisonExpressionParserRuleCall_0; }

		//({AndExpression.leftOperand=current} "&&" rightOperand=ComparisonExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{AndExpression.leftOperand=current}
		public Action getAndExpressionLeftOperandAction_1_0() { return cAndExpressionLeftOperandAction_1_0; }

		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1_1() { return cAmpersandAmpersandKeyword_1_1; }

		//rightOperand=ComparisonExpression
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }

		//ComparisonExpression
		public RuleCall getRightOperandComparisonExpressionParserRuleCall_1_2_0() { return cRightOperandComparisonExpressionParserRuleCall_1_2_0; }
	}

	public class ComparisonExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonExpressionLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cComparatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cComparatorComparatorEnumRuleCall_1_1_0 = (RuleCall)cComparatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandAdditiveExpressionParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		//// validation: leftOperand, rightOperand are Boolean-typed	[√]
		//ComparisonExpression returns Expression:
		//	AdditiveExpression ({ComparisonExpression.leftOperand=current} comparator=Comparator rightOperand=AdditiveExpression)* // left-associative infix binary operator
		//;
		public ParserRule getRule() { return rule; }

		//AdditiveExpression ({ComparisonExpression.leftOperand=current} comparator=Comparator rightOperand=AdditiveExpression)* // left-associative infix binary operator
		public Group getGroup() { return cGroup; }

		//AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }

		//({ComparisonExpression.leftOperand=current} comparator=Comparator rightOperand=AdditiveExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{ComparisonExpression.leftOperand=current}
		public Action getComparisonExpressionLeftOperandAction_1_0() { return cComparisonExpressionLeftOperandAction_1_0; }

		//comparator=Comparator
		public Assignment getComparatorAssignment_1_1() { return cComparatorAssignment_1_1; }

		//Comparator
		public RuleCall getComparatorComparatorEnumRuleCall_1_1_0() { return cComparatorComparatorEnumRuleCall_1_1_0; }

		//rightOperand=AdditiveExpression
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }

		//AdditiveExpression
		public RuleCall getRightOperandAdditiveExpressionParserRuleCall_1_2_0() { return cRightOperandAdditiveExpressionParserRuleCall_1_2_0; }
	}

	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAdditiveExpressionLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorAdditiveOperatorsEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandMultiplicativeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		//AdditiveExpression returns Expression:
		//	MultiplicativeExpression ({AdditiveExpression.leftOperand=current} operator=AdditiveOperators
		//	rightOperand=MultiplicativeExpression)* // left-associative infix binary operator
		//;
		public ParserRule getRule() { return rule; }

		//MultiplicativeExpression ({AdditiveExpression.leftOperand=current} operator=AdditiveOperators
		//rightOperand=MultiplicativeExpression)* // left-associative infix binary operator
		public Group getGroup() { return cGroup; }

		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }

		//({AdditiveExpression.leftOperand=current} operator=AdditiveOperators rightOperand=MultiplicativeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{AdditiveExpression.leftOperand=current}
		public Action getAdditiveExpressionLeftOperandAction_1_0() { return cAdditiveExpressionLeftOperandAction_1_0; }

		//operator=AdditiveOperators
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//AdditiveOperators
		public RuleCall getOperatorAdditiveOperatorsEnumRuleCall_1_1_0() { return cOperatorAdditiveOperatorsEnumRuleCall_1_1_0; }

		//rightOperand=MultiplicativeExpression
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }

		//MultiplicativeExpression
		public RuleCall getRightOperandMultiplicativeExpressionParserRuleCall_1_2_0() { return cRightOperandMultiplicativeExpressionParserRuleCall_1_2_0; }
	}

	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNotExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicativeExpressionLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorMultiplicativeOperatorsEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandNotExpressionParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		//// TODO  overload the + to handle array types as well
		//MultiplicativeExpression returns Expression:
		//	NotExpression ({MultiplicativeExpression.leftOperand=current} operator=MultiplicativeOperators
		//	rightOperand=NotExpression)* // left-associative infix binary operator
		//;
		public ParserRule getRule() { return rule; }

		//NotExpression ({MultiplicativeExpression.leftOperand=current} operator=MultiplicativeOperators
		//rightOperand=NotExpression)* // left-associative infix binary operator
		public Group getGroup() { return cGroup; }

		//NotExpression
		public RuleCall getNotExpressionParserRuleCall_0() { return cNotExpressionParserRuleCall_0; }

		//({MultiplicativeExpression.leftOperand=current} operator=MultiplicativeOperators rightOperand=NotExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{MultiplicativeExpression.leftOperand=current}
		public Action getMultiplicativeExpressionLeftOperandAction_1_0() { return cMultiplicativeExpressionLeftOperandAction_1_0; }

		//operator=MultiplicativeOperators
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//MultiplicativeOperators
		public RuleCall getOperatorMultiplicativeOperatorsEnumRuleCall_1_1_0() { return cOperatorMultiplicativeOperatorsEnumRuleCall_1_1_0; }

		//rightOperand=NotExpression
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }

		//NotExpression
		public RuleCall getRightOperandNotExpressionParserRuleCall_1_2_0() { return cRightOperandNotExpressionParserRuleCall_1_2_0; }
	}

	public class NotExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NotExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInterfaceCallExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNotExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperandNotExpressionParserRuleCall_1_2_0 = (RuleCall)cOperandAssignment_1_2.eContents().get(0);
		
		//NotExpression returns Expression:
		//	InterfaceCallExpression | {NotExpression} "!" operand=NotExpression;
		public ParserRule getRule() { return rule; }

		//InterfaceCallExpression | {NotExpression} "!" operand=NotExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//InterfaceCallExpression
		public RuleCall getInterfaceCallExpressionParserRuleCall_0() { return cInterfaceCallExpressionParserRuleCall_0; }

		//{NotExpression} "!" operand=NotExpression
		public Group getGroup_1() { return cGroup_1; }

		//{NotExpression}
		public Action getNotExpressionAction_1_0() { return cNotExpressionAction_1_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_1_1() { return cExclamationMarkKeyword_1_1; }

		//operand=NotExpression
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }

		//NotExpression
		public RuleCall getOperandNotExpressionParserRuleCall_1_2_0() { return cOperandNotExpressionParserRuleCall_1_2_0; }
	}

	public class InterfaceCallExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InterfaceCallExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFeatureAccessExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cInterfaceCallExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cCallKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cServiceIdAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cServiceIdServiceIdentificationParserRuleCall_1_2_0 = (RuleCall)cServiceIdAssignment_1_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Group cGroup_1_4 = (Group)cGroup_1.eContents().get(4);
		private final Keyword cObserveKeyword_1_4_0 = (Keyword)cGroup_1_4.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_4_1 = (Keyword)cGroup_1_4.eContents().get(1);
		private final Assignment cObserveSitesAssignment_1_4_2 = (Assignment)cGroup_1_4.eContents().get(2);
		private final RuleCall cObserveSitesExpressionParserRuleCall_1_4_2_0 = (RuleCall)cObserveSitesAssignment_1_4_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_4_3 = (Keyword)cGroup_1_4.eContents().get(3);
		private final Assignment cInputAssignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cInputExpressionParserRuleCall_1_5_0 = (RuleCall)cInputAssignment_1_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_6 = (Keyword)cGroup_1.eContents().get(6);
		private final Group cGroup_1_7 = (Group)cGroup_1.eContents().get(7);
		private final Keyword cEqualsSignGreaterThanSignKeyword_1_7_0 = (Keyword)cGroup_1_7.eContents().get(0);
		private final Assignment cCallbackAssignment_1_7_1 = (Assignment)cGroup_1_7.eContents().get(1);
		private final RuleCall cCallbackCallbackExpressionParserRuleCall_1_7_1_0 = (RuleCall)cCallbackAssignment_1_7_1.eContents().get(0);
		private final Group cGroup_1_7_2 = (Group)cGroup_1_7.eContents().get(2);
		private final Keyword cErrorKeyword_1_7_2_0 = (Keyword)cGroup_1_7_2.eContents().get(0);
		private final Assignment cErrorCallbackAssignment_1_7_2_1 = (Assignment)cGroup_1_7_2.eContents().get(1);
		private final RuleCall cErrorCallbackCallbackExpressionParserRuleCall_1_7_2_1_0 = (RuleCall)cErrorCallbackAssignment_1_7_2_1.eContents().get(0);
		
		//// validation: operand.type.booleanTyped							[√]
		//InterfaceCallExpression returns Expression:
		//	FeatureAccessExpression | {InterfaceCallExpression} "call" serviceId=ServiceIdentification "(" ("observe" "["
		//	observeSites+=Expression* "]")? input=Expression? ")" ("=>" callback=CallbackExpression ("@error:"
		//	errorCallback=CallbackExpression)?)?;
		public ParserRule getRule() { return rule; }

		//FeatureAccessExpression | {InterfaceCallExpression} "call" serviceId=ServiceIdentification "(" ("observe" "["
		//observeSites+=Expression* "]")? input=Expression? ")" ("=>" callback=CallbackExpression ("@error:"
		//errorCallback=CallbackExpression)?)?
		public Alternatives getAlternatives() { return cAlternatives; }

		//FeatureAccessExpression
		public RuleCall getFeatureAccessExpressionParserRuleCall_0() { return cFeatureAccessExpressionParserRuleCall_0; }

		//{InterfaceCallExpression} "call" serviceId=ServiceIdentification "(" ("observe" "[" observeSites+=Expression* "]")?
		//input=Expression? ")" ("=>" callback=CallbackExpression ("@error:" errorCallback=CallbackExpression)?)?
		public Group getGroup_1() { return cGroup_1; }

		//{InterfaceCallExpression}
		public Action getInterfaceCallExpressionAction_1_0() { return cInterfaceCallExpressionAction_1_0; }

		//"call"
		public Keyword getCallKeyword_1_1() { return cCallKeyword_1_1; }

		//serviceId=ServiceIdentification
		public Assignment getServiceIdAssignment_1_2() { return cServiceIdAssignment_1_2; }

		//ServiceIdentification
		public RuleCall getServiceIdServiceIdentificationParserRuleCall_1_2_0() { return cServiceIdServiceIdentificationParserRuleCall_1_2_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_3() { return cLeftParenthesisKeyword_1_3; }

		//("observe" "[" observeSites+=Expression* "]")?
		public Group getGroup_1_4() { return cGroup_1_4; }

		//"observe"
		public Keyword getObserveKeyword_1_4_0() { return cObserveKeyword_1_4_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_4_1() { return cLeftSquareBracketKeyword_1_4_1; }

		//observeSites+=Expression*
		public Assignment getObserveSitesAssignment_1_4_2() { return cObserveSitesAssignment_1_4_2; }

		//Expression
		public RuleCall getObserveSitesExpressionParserRuleCall_1_4_2_0() { return cObserveSitesExpressionParserRuleCall_1_4_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_4_3() { return cRightSquareBracketKeyword_1_4_3; }

		//input=Expression?
		public Assignment getInputAssignment_1_5() { return cInputAssignment_1_5; }

		//Expression
		public RuleCall getInputExpressionParserRuleCall_1_5_0() { return cInputExpressionParserRuleCall_1_5_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_6() { return cRightParenthesisKeyword_1_6; }

		//("=>" callback=CallbackExpression ("@error:" errorCallback=CallbackExpression)?)?
		public Group getGroup_1_7() { return cGroup_1_7; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_1_7_0() { return cEqualsSignGreaterThanSignKeyword_1_7_0; }

		//callback=CallbackExpression
		public Assignment getCallbackAssignment_1_7_1() { return cCallbackAssignment_1_7_1; }

		//CallbackExpression
		public RuleCall getCallbackCallbackExpressionParserRuleCall_1_7_1_0() { return cCallbackCallbackExpressionParserRuleCall_1_7_1_0; }

		//("@error:" errorCallback=CallbackExpression)?
		public Group getGroup_1_7_2() { return cGroup_1_7_2; }

		//"@error:"
		public Keyword getErrorKeyword_1_7_2_0() { return cErrorKeyword_1_7_2_0; }

		//errorCallback=CallbackExpression
		public Assignment getErrorCallbackAssignment_1_7_2_1() { return cErrorCallbackAssignment_1_7_2_1; }

		//CallbackExpression
		public RuleCall getErrorCallbackCallbackExpressionParserRuleCall_1_7_2_1_0() { return cErrorCallbackCallbackExpressionParserRuleCall_1_7_2_1_0; }
	}

	public class ServiceIdentificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ServiceIdentification");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cNamedServiceReferenceAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cServiceAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final CrossReference cServiceNamedServiceCrossReference_0_1_0 = (CrossReference)cServiceAssignment_0_1.eContents().get(0);
		private final RuleCall cServiceNamedServiceIDTerminalRuleCall_0_1_0_1 = (RuleCall)cServiceNamedServiceCrossReference_0_1_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cCrudServiceIdentificationAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cCrudTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCrudTypeCrudTypesEnumRuleCall_1_1_0 = (RuleCall)cCrudTypeAssignment_1_1.eContents().get(0);
		private final Assignment cStructureAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final CrossReference cStructureStructureCrossReference_1_2_0 = (CrossReference)cStructureAssignment_1_2.eContents().get(0);
		private final RuleCall cStructureStructureIDTerminalRuleCall_1_2_0_1 = (RuleCall)cStructureStructureCrossReference_1_2_0.eContents().get(1);
		
		/// *
		//	 * validation:
		//	 * 		1-  serviceId.inputType.isAssignableFrom(input.type)																		[√]
		//	 * 		2-  InterfaceCallExpression can only be a lone expression as a statement or the initialisation of a value declaration		[√]
		//	 * / // TODO  more validation? e.g. callback and observeSites are "often" illegal
		//ServiceIdentification:
		//	{NamedServiceReference} service=[backend::NamedService] | {CrudServiceIdentification} crudType=CrudTypes
		//	structure=[struct::Structure];
		public ParserRule getRule() { return rule; }

		//{NamedServiceReference} service=[backend::NamedService] | {CrudServiceIdentification} crudType=CrudTypes
		//structure=[struct::Structure]
		public Alternatives getAlternatives() { return cAlternatives; }

		//{NamedServiceReference} service=[backend::NamedService]
		public Group getGroup_0() { return cGroup_0; }

		//{NamedServiceReference}
		public Action getNamedServiceReferenceAction_0_0() { return cNamedServiceReferenceAction_0_0; }

		//service=[backend::NamedService]
		public Assignment getServiceAssignment_0_1() { return cServiceAssignment_0_1; }

		//[backend::NamedService]
		public CrossReference getServiceNamedServiceCrossReference_0_1_0() { return cServiceNamedServiceCrossReference_0_1_0; }

		//ID
		public RuleCall getServiceNamedServiceIDTerminalRuleCall_0_1_0_1() { return cServiceNamedServiceIDTerminalRuleCall_0_1_0_1; }

		//{CrudServiceIdentification} crudType=CrudTypes structure=[struct::Structure]
		public Group getGroup_1() { return cGroup_1; }

		//{CrudServiceIdentification}
		public Action getCrudServiceIdentificationAction_1_0() { return cCrudServiceIdentificationAction_1_0; }

		//crudType=CrudTypes
		public Assignment getCrudTypeAssignment_1_1() { return cCrudTypeAssignment_1_1; }

		//CrudTypes
		public RuleCall getCrudTypeCrudTypesEnumRuleCall_1_1_0() { return cCrudTypeCrudTypesEnumRuleCall_1_1_0; }

		//structure=[struct::Structure]
		public Assignment getStructureAssignment_1_2() { return cStructureAssignment_1_2; }

		//[struct::Structure]
		public CrossReference getStructureStructureCrossReference_1_2_0() { return cStructureStructureCrossReference_1_2_0; }

		//ID
		public RuleCall getStructureStructureIDTerminalRuleCall_1_2_0_1() { return cStructureStructureIDTerminalRuleCall_1_2_0_1; }
	}

	public class FeatureAccessExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FeatureAccessExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cFeatureAccessExpressionPreviousAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cFeatureAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final CrossReference cFeatureFeatureCrossReference_1_2_0 = (CrossReference)cFeatureAssignment_1_2.eContents().get(0);
		private final RuleCall cFeatureFeatureIDTerminalRuleCall_1_2_0_1 = (RuleCall)cFeatureFeatureCrossReference_1_2_0.eContents().get(1);
		
		//FeatureAccessExpression returns Expression hidden():
		//	PrimaryExpression ({FeatureAccessExpression.previous=current} "." feature=[struct::Feature])* // left-associative infix binary operator
		//;
		public ParserRule getRule() { return rule; }

		//PrimaryExpression ({FeatureAccessExpression.previous=current} "." feature=[struct::Feature])* // left-associative infix binary operator
		public Group getGroup() { return cGroup; }

		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }

		//({FeatureAccessExpression.previous=current} "." feature=[struct::Feature])*
		public Group getGroup_1() { return cGroup_1; }

		//{FeatureAccessExpression.previous=current}
		public Action getFeatureAccessExpressionPreviousAction_1_0() { return cFeatureAccessExpressionPreviousAction_1_0; }

		//"."
		public Keyword getFullStopKeyword_1_1() { return cFullStopKeyword_1_1; }

		//feature=[struct::Feature]
		public Assignment getFeatureAssignment_1_2() { return cFeatureAssignment_1_2; }

		//[struct::Feature]
		public CrossReference getFeatureFeatureCrossReference_1_2_0() { return cFeatureFeatureCrossReference_1_2_0; }

		//ID
		public RuleCall getFeatureFeatureIDTerminalRuleCall_1_2_0_1() { return cFeatureFeatureIDTerminalRuleCall_1_2_0_1; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cLiteralExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCallbackExpressionsParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cStructureCreationExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cValueReferenceOrMethodCallExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cDateExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cBuiltinFunctionExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Action cSelectionExpressionAction_7_0 = (Action)cGroup_7.eContents().get(0);
		private final Keyword cSelectionKeyword_7_1 = (Keyword)cGroup_7.eContents().get(1);
		
		//// scoping: feature in previous.type.features												[√]
		//// validation: previous must be a FeatureAccessExpression or a ValueReferenceExpression		[√]
		//// TODO  add invocation of member methods and such
		//// TODO  use an enum BuiltinMemberFunctions to add "member calls" to FeatureAccessExpression (and add a ton of validation)
		//// (undo cascade of FeatureAccessExpression's hidden())
		//PrimaryExpression returns Expression hidden(WS, ML_COMMENT, SL_COMMENT):
		//	"(" Expression ")" | LiteralExpression | CallbackExpressions | StructureCreationExpression |
		//	ValueReferenceOrMethodCallExpression | DateExpression | BuiltinFunctionExpression | {SelectionExpression} "selection";
		public ParserRule getRule() { return rule; }

		//"(" Expression ")" | LiteralExpression | CallbackExpressions | StructureCreationExpression |
		//ValueReferenceOrMethodCallExpression | DateExpression | BuiltinFunctionExpression | {SelectionExpression} "selection"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" Expression ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//LiteralExpression
		public RuleCall getLiteralExpressionParserRuleCall_1() { return cLiteralExpressionParserRuleCall_1; }

		//CallbackExpressions
		public RuleCall getCallbackExpressionsParserRuleCall_2() { return cCallbackExpressionsParserRuleCall_2; }

		//StructureCreationExpression
		public RuleCall getStructureCreationExpressionParserRuleCall_3() { return cStructureCreationExpressionParserRuleCall_3; }

		//ValueReferenceOrMethodCallExpression
		public RuleCall getValueReferenceOrMethodCallExpressionParserRuleCall_4() { return cValueReferenceOrMethodCallExpressionParserRuleCall_4; }

		//DateExpression
		public RuleCall getDateExpressionParserRuleCall_5() { return cDateExpressionParserRuleCall_5; }

		//BuiltinFunctionExpression
		public RuleCall getBuiltinFunctionExpressionParserRuleCall_6() { return cBuiltinFunctionExpressionParserRuleCall_6; }

		//{SelectionExpression} "selection"
		public Group getGroup_7() { return cGroup_7; }

		//{SelectionExpression}
		public Action getSelectionExpressionAction_7_0() { return cSelectionExpressionAction_7_0; }

		//"selection"
		public Keyword getSelectionKeyword_7_1() { return cSelectionKeyword_7_1; }
	}

	public class DateExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DateExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cDateNowExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cNowKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cDateTodayExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cTodayKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//// validation: SelectionExpression may only be used within CalendarStatement.onSelect		[?]
		//DateExpression:
		//	{DateNowExpression} "now" | {DateTodayExpression} "today";
		public ParserRule getRule() { return rule; }

		//{DateNowExpression} "now" | {DateTodayExpression} "today"
		public Alternatives getAlternatives() { return cAlternatives; }

		//{DateNowExpression} "now"
		public Group getGroup_0() { return cGroup_0; }

		//{DateNowExpression}
		public Action getDateNowExpressionAction_0_0() { return cDateNowExpressionAction_0_0; }

		//"now"
		public Keyword getNowKeyword_0_1() { return cNowKeyword_0_1; }

		//{DateTodayExpression} "today"
		public Group getGroup_1() { return cGroup_1; }

		//{DateTodayExpression}
		public Action getDateTodayExpressionAction_1_0() { return cDateTodayExpressionAction_1_0; }

		//"today"
		public Keyword getTodayKeyword_1_1() { return cTodayKeyword_1_1; }
	}

	public class BuiltinFunctionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuiltinFunctionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFunctionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFunctionBuiltinFunctionsEnumRuleCall_0_0 = (RuleCall)cFunctionAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cArgumentAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgumentExpressionParserRuleCall_2_0 = (RuleCall)cArgumentAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cOnKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cSortFeatureAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cSortFeatureFeatureCrossReference_3_1_0 = (CrossReference)cSortFeatureAssignment_3_1.eContents().get(0);
		private final RuleCall cSortFeatureFeatureIDTerminalRuleCall_3_1_0_1 = (RuleCall)cSortFeatureFeatureCrossReference_3_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//BuiltinFunctionExpression:
		//	function=BuiltinFunctions "(" argument=Expression ("on" sortFeature=[struct::Feature])? ")";
		public ParserRule getRule() { return rule; }

		//function=BuiltinFunctions "(" argument=Expression ("on" sortFeature=[struct::Feature])? ")"
		public Group getGroup() { return cGroup; }

		//function=BuiltinFunctions
		public Assignment getFunctionAssignment_0() { return cFunctionAssignment_0; }

		//BuiltinFunctions
		public RuleCall getFunctionBuiltinFunctionsEnumRuleCall_0_0() { return cFunctionBuiltinFunctionsEnumRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//argument=Expression
		public Assignment getArgumentAssignment_2() { return cArgumentAssignment_2; }

		//Expression
		public RuleCall getArgumentExpressionParserRuleCall_2_0() { return cArgumentExpressionParserRuleCall_2_0; }

		//("on" sortFeature=[struct::Feature])?
		public Group getGroup_3() { return cGroup_3; }

		//"on"
		public Keyword getOnKeyword_3_0() { return cOnKeyword_3_0; }

		//sortFeature=[struct::Feature]
		public Assignment getSortFeatureAssignment_3_1() { return cSortFeatureAssignment_3_1; }

		//[struct::Feature]
		public CrossReference getSortFeatureFeatureCrossReference_3_1_0() { return cSortFeatureFeatureCrossReference_3_1_0; }

		//ID
		public RuleCall getSortFeatureFeatureIDTerminalRuleCall_3_1_0_1() { return cSortFeatureFeatureIDTerminalRuleCall_3_1_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class LiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cStringLiteralExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cBooleanLiteralExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cLiteralAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cLiteralBooleanLiteralsEnumRuleCall_1_1_0 = (RuleCall)cLiteralAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cIntegerLiteralExpressionAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_2_1_0 = (RuleCall)cValueAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cNumberLiteralExpressionAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cValueAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValueNumberLiteralParserRuleCall_3_1_0 = (RuleCall)cValueAssignment_3_1.eContents().get(0);
		private final RuleCall cListLiteralExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cEnumerationLiteralExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cDecisionExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//// TODO  consider adding a `bind` function which has the intent of making the value bound...
		/// *
		//	 * scoping: sortFeature in argument.type.features
		//	 * validation:
		//	 * 		1-  value.type.textuallyTyped if function is 'alert' or 'confirm'								[√]
		//	 * 		2-  argument.type.dateTyped if function is 'toMillis'											[√]
		//	 * 		3-  argument.type.numberTyped if function is 'round'											[√]
		//	 * 		4-	!value.type.structureTyped if function is 'isSet' (warning)									[√]
		//	 * 		5-  argument.type.emailTyped if function is 'isValid'											[√]
		//	 * 		6-  argument.type.listTyped && argument.type.listItemType.structureTyped if function is 'sort'	[ ]
		//	 * 		7-  sortFeature != null iff function is 'sort'													[√]
		//	 * 		8-  value.type.structureTyped if function is 'id'												[√]
		//	 * / // TODO  replace keyword-style expression(s) with implicitly imported functions
		//LiteralExpression:
		//	{StringLiteralExpression} value=STRING | {BooleanLiteralExpression} literal=BooleanLiterals |
		//	{IntegerLiteralExpression} value=INT | {NumberLiteralExpression} value=NumberLiteral | ListLiteralExpression |
		//	EnumerationLiteralExpression | DecisionExpression;
		public ParserRule getRule() { return rule; }

		//{StringLiteralExpression} value=STRING | {BooleanLiteralExpression} literal=BooleanLiterals | {IntegerLiteralExpression}
		//value=INT | {NumberLiteralExpression} value=NumberLiteral | ListLiteralExpression | EnumerationLiteralExpression |
		//DecisionExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//{StringLiteralExpression} value=STRING
		public Group getGroup_0() { return cGroup_0; }

		//{StringLiteralExpression}
		public Action getStringLiteralExpressionAction_0_0() { return cStringLiteralExpressionAction_0_0; }

		//value=STRING
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0_1_0() { return cValueSTRINGTerminalRuleCall_0_1_0; }

		//{BooleanLiteralExpression} literal=BooleanLiterals
		public Group getGroup_1() { return cGroup_1; }

		//{BooleanLiteralExpression}
		public Action getBooleanLiteralExpressionAction_1_0() { return cBooleanLiteralExpressionAction_1_0; }

		//literal=BooleanLiterals
		public Assignment getLiteralAssignment_1_1() { return cLiteralAssignment_1_1; }

		//BooleanLiterals
		public RuleCall getLiteralBooleanLiteralsEnumRuleCall_1_1_0() { return cLiteralBooleanLiteralsEnumRuleCall_1_1_0; }

		//{IntegerLiteralExpression} value=INT
		public Group getGroup_2() { return cGroup_2; }

		//{IntegerLiteralExpression}
		public Action getIntegerLiteralExpressionAction_2_0() { return cIntegerLiteralExpressionAction_2_0; }

		//value=INT
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_2_1_0() { return cValueINTTerminalRuleCall_2_1_0; }

		//{NumberLiteralExpression} value=NumberLiteral
		public Group getGroup_3() { return cGroup_3; }

		//{NumberLiteralExpression}
		public Action getNumberLiteralExpressionAction_3_0() { return cNumberLiteralExpressionAction_3_0; }

		//value=NumberLiteral
		public Assignment getValueAssignment_3_1() { return cValueAssignment_3_1; }

		//NumberLiteral
		public RuleCall getValueNumberLiteralParserRuleCall_3_1_0() { return cValueNumberLiteralParserRuleCall_3_1_0; }

		//ListLiteralExpression
		public RuleCall getListLiteralExpressionParserRuleCall_4() { return cListLiteralExpressionParserRuleCall_4; }

		//EnumerationLiteralExpression
		public RuleCall getEnumerationLiteralExpressionParserRuleCall_5() { return cEnumerationLiteralExpressionParserRuleCall_5; }

		//DecisionExpression
		public RuleCall getDecisionExpressionParserRuleCall_6() { return cDecisionExpressionParserRuleCall_6; }
	}

	public class ListLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ListLiteralExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cListLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cMembersAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMembersExpressionParserRuleCall_2_0 = (RuleCall)cMembersAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// TODO  add a literal expression for strings that require HTML escaping?
		//ListLiteralExpression:
		//	{ListLiteralExpression} "[" members+=Expression* "]";
		public ParserRule getRule() { return rule; }

		//{ListLiteralExpression} "[" members+=Expression* "]"
		public Group getGroup() { return cGroup; }

		//{ListLiteralExpression}
		public Action getListLiteralExpressionAction_0() { return cListLiteralExpressionAction_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }

		//members+=Expression*
		public Assignment getMembersAssignment_2() { return cMembersAssignment_2; }

		//Expression
		public RuleCall getMembersExpressionParserRuleCall_2_0() { return cMembersExpressionParserRuleCall_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}

	public class EnumerationLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumerationLiteralExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEnumerationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cEnumerationEnumerationCrossReference_0_0 = (CrossReference)cEnumerationAssignment_0.eContents().get(0);
		private final RuleCall cEnumerationEnumerationIDTerminalRuleCall_0_0_1 = (RuleCall)cEnumerationEnumerationCrossReference_0_0.eContents().get(1);
		private final Keyword cColonColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLiteralAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cLiteralEnumerationLiteralCrossReference_2_0 = (CrossReference)cLiteralAssignment_2.eContents().get(0);
		private final RuleCall cLiteralEnumerationLiteralEnumerationNameParserRuleCall_2_0_1 = (RuleCall)cLiteralEnumerationLiteralCrossReference_2_0.eContents().get(1);
		
		//// validation: members (if any) must be compatible with each other - for now this means that everything must be compatible with the first member	[√]
		//EnumerationLiteralExpression hidden():
		//	enumeration=[struct::Enumeration] "::" literal=[struct::EnumerationLiteral|EnumerationName];
		public ParserRule getRule() { return rule; }

		//enumeration=[struct::Enumeration] "::" literal=[struct::EnumerationLiteral|EnumerationName]
		public Group getGroup() { return cGroup; }

		//enumeration=[struct::Enumeration]
		public Assignment getEnumerationAssignment_0() { return cEnumerationAssignment_0; }

		//[struct::Enumeration]
		public CrossReference getEnumerationEnumerationCrossReference_0_0() { return cEnumerationEnumerationCrossReference_0_0; }

		//ID
		public RuleCall getEnumerationEnumerationIDTerminalRuleCall_0_0_1() { return cEnumerationEnumerationIDTerminalRuleCall_0_0_1; }

		//"::"
		public Keyword getColonColonKeyword_1() { return cColonColonKeyword_1; }

		//literal=[struct::EnumerationLiteral|EnumerationName]
		public Assignment getLiteralAssignment_2() { return cLiteralAssignment_2; }

		//[struct::EnumerationLiteral|EnumerationName]
		public CrossReference getLiteralEnumerationLiteralCrossReference_2_0() { return cLiteralEnumerationLiteralCrossReference_2_0; }

		//EnumerationName
		public RuleCall getLiteralEnumerationLiteralEnumerationNameParserRuleCall_2_0_1() { return cLiteralEnumerationLiteralEnumerationNameParserRuleCall_2_0_1; }
	}

	public class NumberLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumberLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//// (datatype rule)
		//NumberLiteral returns ecore::EBigDecimal hidden():
		//	INT "." INT;
		public ParserRule getRule() { return rule; }

		//INT "." INT
		public Group getGroup() { return cGroup; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
	}

	public class DecisionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DecisionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDecisionExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDecideKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCasesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCasesDecisionCaseParserRuleCall_3_0 = (RuleCall)cCasesAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cDefaultKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Keyword cColonKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Assignment cDefaultValueExprAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cDefaultValueExprExpressionParserRuleCall_4_2_0 = (RuleCall)cDefaultValueExprAssignment_4_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//DecisionExpression:
		//	{DecisionExpression} "decide" "{" cases+=DecisionCase* ("default" ":" defaultValueExpr=Expression)? "}";
		public ParserRule getRule() { return rule; }

		//{DecisionExpression} "decide" "{" cases+=DecisionCase* ("default" ":" defaultValueExpr=Expression)? "}"
		public Group getGroup() { return cGroup; }

		//{DecisionExpression}
		public Action getDecisionExpressionAction_0() { return cDecisionExpressionAction_0; }

		//"decide"
		public Keyword getDecideKeyword_1() { return cDecideKeyword_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//cases+=DecisionCase*
		public Assignment getCasesAssignment_3() { return cCasesAssignment_3; }

		//DecisionCase
		public RuleCall getCasesDecisionCaseParserRuleCall_3_0() { return cCasesDecisionCaseParserRuleCall_3_0; }

		//("default" ":" defaultValueExpr=Expression)?
		public Group getGroup_4() { return cGroup_4; }

		//"default"
		public Keyword getDefaultKeyword_4_0() { return cDefaultKeyword_4_0; }

		//":"
		public Keyword getColonKeyword_4_1() { return cColonKeyword_4_1; }

		//defaultValueExpr=Expression
		public Assignment getDefaultValueExprAssignment_4_2() { return cDefaultValueExprAssignment_4_2; }

		//Expression
		public RuleCall getDefaultValueExprExpressionParserRuleCall_4_2_0() { return cDefaultValueExprExpressionParserRuleCall_4_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class DecisionCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DecisionCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cGuardExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cGuardExprExpressionParserRuleCall_1_0 = (RuleCall)cGuardExprAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueExprAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueExprExpressionParserRuleCall_3_0 = (RuleCall)cValueExprAssignment_3.eContents().get(0);
		
		/// *
		//	 * type: cases.head.valueExpr.type or defaultValueExpr.type							[√]
		//	 * validation:
		//	 * 		1-  !cases.empty (warning)													[√]
		//	 * 		2-  type.isAssignableFrom(defaultValueExpr.type)							[√]
		//	 * / DecisionCase:
		//	"case" guardExpr=Expression ":" valueExpr=Expression;
		public ParserRule getRule() { return rule; }

		//"case" guardExpr=Expression ":" valueExpr=Expression
		public Group getGroup() { return cGroup; }

		//"case"
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }

		//guardExpr=Expression
		public Assignment getGuardExprAssignment_1() { return cGuardExprAssignment_1; }

		//Expression
		public RuleCall getGuardExprExpressionParserRuleCall_1_0() { return cGuardExprExpressionParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_3() { return cValueExprAssignment_3; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_3_0() { return cValueExprExpressionParserRuleCall_3_0; }
	}

	public class CallbackExpressionsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CallbackExpressions");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCallbackExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cCallbackResponseExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cResponseKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cCallbackErrorResponseExpressionAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cErrorKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		
		/// *
		//	 * validation:
		//	 * 		1-  guardExpr.type.booleanTyped												[√]
		//	 * 		2-  containing(DecisionExpression).type.isAssignableFrom(guardExpr.type)	[√]
		//	 * / CallbackExpressions:
		//	CallbackExpression | {CallbackResponseExpression} // validation: only useable within callbacks	[√]
		//	"response" | {CallbackErrorResponseExpression} // validation: only useable within callbacks	[√]
		//	"error";
		public ParserRule getRule() { return rule; }

		//CallbackExpression | {CallbackResponseExpression} // validation: only useable within callbacks	[√]
		//"response" | {CallbackErrorResponseExpression} // validation: only useable within callbacks	[√]
		//"error"
		public Alternatives getAlternatives() { return cAlternatives; }

		//CallbackExpression
		public RuleCall getCallbackExpressionParserRuleCall_0() { return cCallbackExpressionParserRuleCall_0; }

		//{CallbackResponseExpression} // validation: only useable within callbacks	[√]
		//"response"
		public Group getGroup_1() { return cGroup_1; }

		//{CallbackResponseExpression}
		public Action getCallbackResponseExpressionAction_1_0() { return cCallbackResponseExpressionAction_1_0; }

		//// validation: only useable within callbacks	[√]
		//"response"
		public Keyword getResponseKeyword_1_1() { return cResponseKeyword_1_1; }

		//{CallbackErrorResponseExpression} // validation: only useable within callbacks	[√]
		//"error"
		public Group getGroup_2() { return cGroup_2; }

		//{CallbackErrorResponseExpression}
		public Action getCallbackErrorResponseExpressionAction_2_0() { return cCallbackErrorResponseExpressionAction_2_0; }

		//// validation: only useable within callbacks	[√]
		//"error"
		public Keyword getErrorKeyword_2_1() { return cErrorKeyword_2_1; }
	}

	public class CallbackExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CallbackExpression");
		private final Assignment cStatementBlockAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementBlockStatementBlockParserRuleCall_0 = (RuleCall)cStatementBlockAssignment.eContents().get(0);
		
		//CallbackExpression:
		//	statementBlock=StatementBlock;
		public ParserRule getRule() { return rule; }

		//statementBlock=StatementBlock
		public Assignment getStatementBlockAssignment() { return cStatementBlockAssignment; }

		//StatementBlock
		public RuleCall getStatementBlockStatementBlockParserRuleCall_0() { return cStatementBlockStatementBlockParserRuleCall_0; }
	}

	public class StructureCreationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StructureCreationExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNewKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStructureAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cStructureStructureCrossReference_1_0 = (CrossReference)cStructureAssignment_1.eContents().get(0);
		private final RuleCall cStructureStructureIDTerminalRuleCall_1_0_1 = (RuleCall)cStructureStructureCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAssignmentsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAssignmentsFeatureAssignmentParserRuleCall_3_0 = (RuleCall)cAssignmentsAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//StructureCreationExpression:
		//	"new" structure=[struct::Structure] "(" assignments+=FeatureAssignment* ")";
		public ParserRule getRule() { return rule; }

		//"new" structure=[struct::Structure] "(" assignments+=FeatureAssignment* ")"
		public Group getGroup() { return cGroup; }

		//"new"
		public Keyword getNewKeyword_0() { return cNewKeyword_0; }

		//structure=[struct::Structure]
		public Assignment getStructureAssignment_1() { return cStructureAssignment_1; }

		//[struct::Structure]
		public CrossReference getStructureStructureCrossReference_1_0() { return cStructureStructureCrossReference_1_0; }

		//ID
		public RuleCall getStructureStructureIDTerminalRuleCall_1_0_1() { return cStructureStructureIDTerminalRuleCall_1_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//assignments+=FeatureAssignment*
		public Assignment getAssignmentsAssignment_3() { return cAssignmentsAssignment_3; }

		//FeatureAssignment
		public RuleCall getAssignmentsFeatureAssignmentParserRuleCall_3_0() { return cAssignmentsFeatureAssignmentParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class FeatureAssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FeatureAssignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFeatureAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cFeatureFeatureCrossReference_0_0 = (CrossReference)cFeatureAssignment_0.eContents().get(0);
		private final RuleCall cFeatureFeatureIDTerminalRuleCall_0_0_1 = (RuleCall)cFeatureFeatureCrossReference_0_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueExprExpressionParserRuleCall_2_0 = (RuleCall)cValueExprAssignment_2.eContents().get(0);
		
		//// validation: features may not be duplicately assigned						[√]
		//FeatureAssignment:
		//	feature=[struct::Feature] "=" valueExpr=Expression;
		public ParserRule getRule() { return rule; }

		//feature=[struct::Feature] "=" valueExpr=Expression
		public Group getGroup() { return cGroup; }

		//feature=[struct::Feature]
		public Assignment getFeatureAssignment_0() { return cFeatureAssignment_0; }

		//[struct::Feature]
		public CrossReference getFeatureFeatureCrossReference_0_0() { return cFeatureFeatureCrossReference_0_0; }

		//ID
		public RuleCall getFeatureFeatureIDTerminalRuleCall_0_0_1() { return cFeatureFeatureIDTerminalRuleCall_0_0_1; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_2() { return cValueExprAssignment_2; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_2_0() { return cValueExprExpressionParserRuleCall_2_0; }
	}

	public class ValueReferenceOrMethodCallExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValueReferenceOrMethodCallExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cReferenceExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMethodCallExpressionMethodRefAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cArgumentListAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cArgumentListArgumentListParserRuleCall_1_1_0 = (RuleCall)cArgumentListAssignment_1_1.eContents().get(0);
		
		//// scoping: feature in containing(StructureCreationExpression).features		[√]
		//// validation: feature.type.isAssignableFrom(valueExpr.type)				[√]
		//ValueReferenceOrMethodCallExpression:
		//	ReferenceExpression ({MethodCallExpression.methodRef=current} => argumentList=ArgumentList)?;
		public ParserRule getRule() { return rule; }

		//ReferenceExpression ({MethodCallExpression.methodRef=current} => argumentList=ArgumentList)?
		public Group getGroup() { return cGroup; }

		//ReferenceExpression
		public RuleCall getReferenceExpressionParserRuleCall_0() { return cReferenceExpressionParserRuleCall_0; }

		//({MethodCallExpression.methodRef=current} => argumentList=ArgumentList)?
		public Group getGroup_1() { return cGroup_1; }

		//{MethodCallExpression.methodRef=current}
		public Action getMethodCallExpressionMethodRefAction_1_0() { return cMethodCallExpressionMethodRefAction_1_0; }

		//=> argumentList=ArgumentList
		public Assignment getArgumentListAssignment_1_1() { return cArgumentListAssignment_1_1; }

		//ArgumentList
		public RuleCall getArgumentListArgumentListParserRuleCall_1_1_0() { return cArgumentListArgumentListParserRuleCall_1_1_0; }
	}

	public class ReferenceExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReferenceExpression");
		private final Assignment cRefAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cRefReferableCrossReference_0 = (CrossReference)cRefAssignment.eContents().get(0);
		private final RuleCall cRefReferableIDTerminalRuleCall_0_1 = (RuleCall)cRefReferableCrossReference_0.eContents().get(1);
		
		/// *
		//	 * validation (on MethodCallExpression):
		//	 * 		1-  methodRef.ref must be a Method										[√]
		//	 * 		2-  all parameters of methodRef.ref are covered and no more than once	[√]
		//	 * / // TODO  harden type calculation to deal with recursive call chains (+ validation?)
		//ReferenceExpression:
		//	ref=[Referable];
		public ParserRule getRule() { return rule; }

		//ref=[Referable]
		public Assignment getRefAssignment() { return cRefAssignment; }

		//[Referable]
		public CrossReference getRefReferableCrossReference_0() { return cRefReferableCrossReference_0; }

		//ID
		public RuleCall getRefReferableIDTerminalRuleCall_0_1() { return cRefReferableIDTerminalRuleCall_0_1; }
	}

	public class ReferableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Referable");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cValueParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cParameterParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cListVariableParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cMethodParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// validation: ref cannot be a method if eContainer is not a MethodCallExpression	[√]
		/// *
		// * TODO  consider adding a ValidID datatype rule and use that everywhere (including in cross-references: |ValidID)
		// * 			instead of ID to allow certain keywords (such as password, email and when) as valid identifiers.
		// * / // (synthetic type)
		/// *
		//	 * scoping: referables must come from local context
		//	 * 
		//	 * locality:
		//	 * 		- within ListElement: 			index-variables + (outer:) values + parameters + top-level methods	[√]
		//	 * 		- within DefinedViewable:		values + parameters + top-level methods								[√]
		//	 * 		- within Method(Definition):	parameters + top-level methods										[√]
		//	 * 		- within Statement:				preceding local values + scope from Method(Definition)				[√]		TODO  fix bug w.r.t. nested statement blocks? (not due to async block...)
		//	 * 		- within CallbackExpression:	preceding local values + scope from Element							[ ]		TODO  implement
		//	 * / Referable:
		//	Value | Parameter | ListVariable | Method;
		public ParserRule getRule() { return rule; }

		//Value | Parameter | ListVariable | Method
		public Alternatives getAlternatives() { return cAlternatives; }

		//Value
		public RuleCall getValueParserRuleCall_0() { return cValueParserRuleCall_0; }

		//Parameter
		public RuleCall getParameterParserRuleCall_1() { return cParameterParserRuleCall_1; }

		//ListVariable
		public RuleCall getListVariableParserRuleCall_2() { return cListVariableParserRuleCall_2; }

		//Method
		public RuleCall getMethodParserRuleCall_3() { return cMethodParserRuleCall_3; }
	}
	
	
	public class ViewableTypesElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ViewableTypes");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cScreenEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cScreenScreenKeyword_0_0 = (Keyword)cScreenEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cComponentEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cComponentComponentKeyword_1_0 = (Keyword)cComponentEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ViewableTypes:
		//	screen | component;
		public EnumRule getRule() { return rule; }

		//screen | component
		public Alternatives getAlternatives() { return cAlternatives; }

		//screen
		public EnumLiteralDeclaration getScreenEnumLiteralDeclaration_0() { return cScreenEnumLiteralDeclaration_0; }

		//"screen"
		public Keyword getScreenScreenKeyword_0_0() { return cScreenScreenKeyword_0_0; }

		//component
		public EnumLiteralDeclaration getComponentEnumLiteralDeclaration_1() { return cComponentEnumLiteralDeclaration_1; }

		//"component"
		public Keyword getComponentComponentKeyword_1_0() { return cComponentComponentKeyword_1_0; }
	}

	public class ValueTypesElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ValueTypes");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cVariableEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cVariableEqualsSignKeyword_0_0 = (Keyword)cVariableEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDerivedEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDerivedLessThanSignHyphenMinusKeyword_1_0 = (Keyword)cDerivedEnumLiteralDeclaration_1.eContents().get(0);
		
		//// validation: either the type, the value or both must be declared, must match and the value should be observable	[√]
		//// (TODO  straighten spec out)
		//enum ValueTypes:
		//	variable="=" | derived="<-";
		public EnumRule getRule() { return rule; }

		//variable="=" | derived="<-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//variable="="
		public EnumLiteralDeclaration getVariableEnumLiteralDeclaration_0() { return cVariableEnumLiteralDeclaration_0; }

		//"="
		public Keyword getVariableEqualsSignKeyword_0_0() { return cVariableEqualsSignKeyword_0_0; }

		//derived="<-"
		public EnumLiteralDeclaration getDerivedEnumLiteralDeclaration_1() { return cDerivedEnumLiteralDeclaration_1; }

		//"<-"
		public Keyword getDerivedLessThanSignHyphenMinusKeyword_1_0() { return cDerivedLessThanSignHyphenMinusKeyword_1_0; }
	}

	public class GroupOrientationsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "GroupOrientations");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cVerticalEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cVerticalVerticalKeyword_0_0 = (Keyword)cVerticalEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cHorizontalEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cHorizontalHorizontalKeyword_1_0 = (Keyword)cHorizontalEnumLiteralDeclaration_1.eContents().get(0);
		
		/// *
		//	 * Note: alternatives have > 0 cardinality to avoid an ambiguity.
		//	 * (Haven't found out yet how to avoid that with a syntactic predicate...)
		//	 * / enum GroupOrientations:
		//	vertical | // vertical is default (1st literal)
		//	horizontal;
		public EnumRule getRule() { return rule; }

		//vertical | // vertical is default (1st literal)
		//horizontal
		public Alternatives getAlternatives() { return cAlternatives; }

		//vertical
		public EnumLiteralDeclaration getVerticalEnumLiteralDeclaration_0() { return cVerticalEnumLiteralDeclaration_0; }

		//"vertical"
		public Keyword getVerticalVerticalKeyword_0_0() { return cVerticalVerticalKeyword_0_0; }

		//// vertical is default (1st literal)
		//horizontal
		public EnumLiteralDeclaration getHorizontalEnumLiteralDeclaration_1() { return cHorizontalEnumLiteralDeclaration_1; }

		//"horizontal"
		public Keyword getHorizontalHorizontalKeyword_1_0() { return cHorizontalHorizontalKeyword_1_0; }
	}

	public class VerticalAlignmentElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "VerticalAlignment");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTopEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTopTopKeyword_0_0 = (Keyword)cTopEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cBottomEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cBottomBottomKeyword_1_0 = (Keyword)cBottomEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMiddleEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMiddleMiddleKeyword_2_0 = (Keyword)cMiddleEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum VerticalAlignment:
		//	top | bottom | middle;
		public EnumRule getRule() { return rule; }

		//top | bottom | middle
		public Alternatives getAlternatives() { return cAlternatives; }

		//top
		public EnumLiteralDeclaration getTopEnumLiteralDeclaration_0() { return cTopEnumLiteralDeclaration_0; }

		//"top"
		public Keyword getTopTopKeyword_0_0() { return cTopTopKeyword_0_0; }

		//bottom
		public EnumLiteralDeclaration getBottomEnumLiteralDeclaration_1() { return cBottomEnumLiteralDeclaration_1; }

		//"bottom"
		public Keyword getBottomBottomKeyword_1_0() { return cBottomBottomKeyword_1_0; }

		//middle
		public EnumLiteralDeclaration getMiddleEnumLiteralDeclaration_2() { return cMiddleEnumLiteralDeclaration_2; }

		//"middle"
		public Keyword getMiddleMiddleKeyword_2_0() { return cMiddleMiddleKeyword_2_0; }
	}

	public class AssignmentOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAssignEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAssignEqualsSignKeyword_0_0 = (Keyword)cAssignEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cAddEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cAddPlusSignEqualsSignKeyword_1_0 = (Keyword)cAddEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cSubEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cSubHyphenMinusEqualsSignKeyword_2_0 = (Keyword)cSubEnumLiteralDeclaration_2.eContents().get(0);
		
		//// TODO  split out specification according to whether rhs is null and again for != null according to operator (assignment vs. the others)
		/// *
		//	 * validation:
		//	 * 		1-  lhs must be a valid left-hand side		[?]
		//	 * 		2-  lhs.type.isAssignableFrom(rhs.type)		[?]
		//	 * TODO  rework
		//	 * / / *
		//	 * This beasty has wildly differing semantics depending on whether it represents
		//	 * 		*) a assigment			<=> rhs != null		(can also be a sum assignment)
		//	 * 		*) a lone expression 	<=> rhs == null		(with some restrictions on the exact expression type)
		//	 * / // TODO  consider making this into an operator as sub type of Expression again - however, during last experiment this caused a lot of non-LL(*)-ness
		//enum AssignmentOperator:
		//	assign="=" | add="+=" | sub="-=";
		public EnumRule getRule() { return rule; }

		//assign="=" | add="+=" | sub="-="
		public Alternatives getAlternatives() { return cAlternatives; }

		//assign="="
		public EnumLiteralDeclaration getAssignEnumLiteralDeclaration_0() { return cAssignEnumLiteralDeclaration_0; }

		//"="
		public Keyword getAssignEqualsSignKeyword_0_0() { return cAssignEqualsSignKeyword_0_0; }

		//add="+="
		public EnumLiteralDeclaration getAddEnumLiteralDeclaration_1() { return cAddEnumLiteralDeclaration_1; }

		//"+="
		public Keyword getAddPlusSignEqualsSignKeyword_1_0() { return cAddPlusSignEqualsSignKeyword_1_0; }

		//sub="-="
		public EnumLiteralDeclaration getSubEnumLiteralDeclaration_2() { return cSubEnumLiteralDeclaration_2; }

		//"-="
		public Keyword getSubHyphenMinusEqualsSignKeyword_2_0() { return cSubHyphenMinusEqualsSignKeyword_2_0; }
	}

	public class ComparatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "Comparator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEqualsEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEqualsEqualsSignEqualsSignKeyword_0_0 = (Keyword)cEqualsEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNotEqualsEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNotEqualsExclamationMarkEqualsSignKeyword_1_0 = (Keyword)cNotEqualsEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cBiggerEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cBiggerGreaterThanSignKeyword_2_0 = (Keyword)cBiggerEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cBiggerEqualsEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cBiggerEqualsGreaterThanSignEqualsSignKeyword_3_0 = (Keyword)cBiggerEqualsEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cSmallerEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cSmallerLessThanSignKeyword_4_0 = (Keyword)cSmallerEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cSmallerEqualsEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cSmallerEqualsLessThanSignEqualsSignKeyword_5_0 = (Keyword)cSmallerEqualsEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cIsInEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cIsInInKeyword_6_0 = (Keyword)cIsInEnumLiteralDeclaration_6.eContents().get(0);
		
		//// validation: leftOperand.type == rightOperand.type		[√]
		//enum Comparator:
		//	equals="==" | notEquals="!=" | bigger=">" | biggerEquals=">=" | smaller="<" | smallerEquals="<=" | isIn="in";
		public EnumRule getRule() { return rule; }

		//equals="==" | notEquals="!=" | bigger=">" | biggerEquals=">=" | smaller="<" | smallerEquals="<=" | isIn="in"
		public Alternatives getAlternatives() { return cAlternatives; }

		//equals="=="
		public EnumLiteralDeclaration getEqualsEnumLiteralDeclaration_0() { return cEqualsEnumLiteralDeclaration_0; }

		//"=="
		public Keyword getEqualsEqualsSignEqualsSignKeyword_0_0() { return cEqualsEqualsSignEqualsSignKeyword_0_0; }

		//notEquals="!="
		public EnumLiteralDeclaration getNotEqualsEnumLiteralDeclaration_1() { return cNotEqualsEnumLiteralDeclaration_1; }

		//"!="
		public Keyword getNotEqualsExclamationMarkEqualsSignKeyword_1_0() { return cNotEqualsExclamationMarkEqualsSignKeyword_1_0; }

		//bigger=">"
		public EnumLiteralDeclaration getBiggerEnumLiteralDeclaration_2() { return cBiggerEnumLiteralDeclaration_2; }

		//">"
		public Keyword getBiggerGreaterThanSignKeyword_2_0() { return cBiggerGreaterThanSignKeyword_2_0; }

		//biggerEquals=">="
		public EnumLiteralDeclaration getBiggerEqualsEnumLiteralDeclaration_3() { return cBiggerEqualsEnumLiteralDeclaration_3; }

		//">="
		public Keyword getBiggerEqualsGreaterThanSignEqualsSignKeyword_3_0() { return cBiggerEqualsGreaterThanSignEqualsSignKeyword_3_0; }

		//smaller="<"
		public EnumLiteralDeclaration getSmallerEnumLiteralDeclaration_4() { return cSmallerEnumLiteralDeclaration_4; }

		//"<"
		public Keyword getSmallerLessThanSignKeyword_4_0() { return cSmallerLessThanSignKeyword_4_0; }

		//smallerEquals="<="
		public EnumLiteralDeclaration getSmallerEqualsEnumLiteralDeclaration_5() { return cSmallerEqualsEnumLiteralDeclaration_5; }

		//"<="
		public Keyword getSmallerEqualsLessThanSignEqualsSignKeyword_5_0() { return cSmallerEqualsLessThanSignEqualsSignKeyword_5_0; }

		//isIn="in"
		public EnumLiteralDeclaration getIsInEnumLiteralDeclaration_6() { return cIsInEnumLiteralDeclaration_6; }

		//"in"
		public Keyword getIsInInKeyword_6_0() { return cIsInInKeyword_6_0; }
	}

	public class AdditiveOperatorsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AdditiveOperators");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPlusEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPlusPlusSignKeyword_0_0 = (Keyword)cPlusEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMinusEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMinusHyphenMinusKeyword_1_0 = (Keyword)cMinusEnumLiteralDeclaration_1.eContents().get(0);
		
		//// validation: leftOperand, rightOperand must be numerically-typed	[√]
		//enum AdditiveOperators:
		//	plus="+" | minus="-";
		public EnumRule getRule() { return rule; }

		//plus="+" | minus="-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//plus="+"
		public EnumLiteralDeclaration getPlusEnumLiteralDeclaration_0() { return cPlusEnumLiteralDeclaration_0; }

		//"+"
		public Keyword getPlusPlusSignKeyword_0_0() { return cPlusPlusSignKeyword_0_0; }

		//minus="-"
		public EnumLiteralDeclaration getMinusEnumLiteralDeclaration_1() { return cMinusEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMinusHyphenMinusKeyword_1_0() { return cMinusHyphenMinusKeyword_1_0; }
	}

	public class MultiplicativeOperatorsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicativeOperators");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMultEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMultAsteriskKeyword_0_0 = (Keyword)cMultEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDivEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDivSolidusKeyword_1_0 = (Keyword)cDivEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cModEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cModPercentSignKeyword_2_0 = (Keyword)cModEnumLiteralDeclaration_2.eContents().get(0);
		
		//// validation: leftOperand, rightOperand must be numerically-typed	[√]
		//enum MultiplicativeOperators:
		//	mult="*" | div="/" | mod="%";
		public EnumRule getRule() { return rule; }

		//mult="*" | div="/" | mod="%"
		public Alternatives getAlternatives() { return cAlternatives; }

		//mult="*"
		public EnumLiteralDeclaration getMultEnumLiteralDeclaration_0() { return cMultEnumLiteralDeclaration_0; }

		//"*"
		public Keyword getMultAsteriskKeyword_0_0() { return cMultAsteriskKeyword_0_0; }

		//div="/"
		public EnumLiteralDeclaration getDivEnumLiteralDeclaration_1() { return cDivEnumLiteralDeclaration_1; }

		//"/"
		public Keyword getDivSolidusKeyword_1_0() { return cDivSolidusKeyword_1_0; }

		//mod="%"
		public EnumLiteralDeclaration getModEnumLiteralDeclaration_2() { return cModEnumLiteralDeclaration_2; }

		//"%"
		public Keyword getModPercentSignKeyword_2_0() { return cModPercentSignKeyword_2_0; }
	}

	public class CrudTypesElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "CrudTypes");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCreateEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCreateCreateKeyword_0_0 = (Keyword)cCreateEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cGetByIdEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cGetByIdGetByIdKeyword_1_0 = (Keyword)cGetByIdEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cUpdateEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cUpdateUpdateKeyword_2_0 = (Keyword)cUpdateEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cDeleteEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cDeleteDeleteKeyword_3_0 = (Keyword)cDeleteEnumLiteralDeclaration_3.eContents().get(0);
		
		//// validation: check that a used CrudService(Identification) is actually declared somewhere		[ ]
		/// *
		//	 * Note: that condition is (somewhat) hard to check since .sim_back only have outgoing references
		//	 * and no incoming ones, so that they don't end up in the same ResourceSet as .sim_ui - at least,
		//	 * during normal editor usage.
		//	 * / // validation: serviceId."interface".inputType.isAssignableFrom(input.type)		[√]
		//// copied from SimScript-Backend DSL grammar:
		//enum CrudTypes:
		//	create | getById="get-by-id" | update | delete;
		public EnumRule getRule() { return rule; }

		//create | getById="get-by-id" | update | delete
		public Alternatives getAlternatives() { return cAlternatives; }

		//create
		public EnumLiteralDeclaration getCreateEnumLiteralDeclaration_0() { return cCreateEnumLiteralDeclaration_0; }

		//"create"
		public Keyword getCreateCreateKeyword_0_0() { return cCreateCreateKeyword_0_0; }

		//getById="get-by-id"
		public EnumLiteralDeclaration getGetByIdEnumLiteralDeclaration_1() { return cGetByIdEnumLiteralDeclaration_1; }

		//"get-by-id"
		public Keyword getGetByIdGetByIdKeyword_1_0() { return cGetByIdGetByIdKeyword_1_0; }

		//update
		public EnumLiteralDeclaration getUpdateEnumLiteralDeclaration_2() { return cUpdateEnumLiteralDeclaration_2; }

		//"update"
		public Keyword getUpdateUpdateKeyword_2_0() { return cUpdateUpdateKeyword_2_0; }

		//delete
		public EnumLiteralDeclaration getDeleteEnumLiteralDeclaration_3() { return cDeleteEnumLiteralDeclaration_3; }

		//"delete"
		public Keyword getDeleteDeleteKeyword_3_0() { return cDeleteDeleteKeyword_3_0; }
	}

	public class BuiltinFunctionsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "BuiltinFunctions");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cIsSetEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cIsSetIsSetKeyword_0_0 = (Keyword)cIsSetEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cAlertEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cAlertAlertKeyword_1_0 = (Keyword)cAlertEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cConfirmEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cConfirmConfirmKeyword_2_0 = (Keyword)cConfirmEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cCopyOfEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cCopyOfCopyOfKeyword_3_0 = (Keyword)cCopyOfEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cToMillisEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cToMillisToMillisKeyword_4_0 = (Keyword)cToMillisEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cRoundEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cRoundRoundKeyword_5_0 = (Keyword)cRoundEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cSortEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cSortSortKeyword_6_0 = (Keyword)cSortEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cIsValidEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cIsValidIsValidKeyword_7_0 = (Keyword)cIsValidEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cIdEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cIdIdKeyword_8_0 = (Keyword)cIdEnumLiteralDeclaration_8.eContents().get(0);
		
		//enum BuiltinFunctions:
		//	isSet | alert | confirm | // copy an object									Note: used for Blaasfunctie.nl!
		//	copyOf | // convert a Date to milliseconds, for calculation
		//	toMillis | // rounds a Number to an Integer
		//	round | // sort a list
		//	sort | // validates some simple-typed lhs'es
		//	isValid | // retrieves the (internal, generated) id of a structure as String
		//	id;
		public EnumRule getRule() { return rule; }

		//isSet | alert | confirm | // copy an object									Note: used for Blaasfunctie.nl!
		//copyOf | // convert a Date to milliseconds, for calculation
		//toMillis | // rounds a Number to an Integer
		//round | // sort a list
		//sort | // validates some simple-typed lhs'es
		//isValid | // retrieves the (internal, generated) id of a structure as String
		//id
		public Alternatives getAlternatives() { return cAlternatives; }

		//isSet
		public EnumLiteralDeclaration getIsSetEnumLiteralDeclaration_0() { return cIsSetEnumLiteralDeclaration_0; }

		//"isSet"
		public Keyword getIsSetIsSetKeyword_0_0() { return cIsSetIsSetKeyword_0_0; }

		//alert
		public EnumLiteralDeclaration getAlertEnumLiteralDeclaration_1() { return cAlertEnumLiteralDeclaration_1; }

		//"alert"
		public Keyword getAlertAlertKeyword_1_0() { return cAlertAlertKeyword_1_0; }

		//confirm
		public EnumLiteralDeclaration getConfirmEnumLiteralDeclaration_2() { return cConfirmEnumLiteralDeclaration_2; }

		//"confirm"
		public Keyword getConfirmConfirmKeyword_2_0() { return cConfirmConfirmKeyword_2_0; }

		//// copy an object									Note: used for Blaasfunctie.nl!
		//copyOf
		public EnumLiteralDeclaration getCopyOfEnumLiteralDeclaration_3() { return cCopyOfEnumLiteralDeclaration_3; }

		//"copyOf"
		public Keyword getCopyOfCopyOfKeyword_3_0() { return cCopyOfCopyOfKeyword_3_0; }

		//// convert a Date to milliseconds, for calculation
		//toMillis
		public EnumLiteralDeclaration getToMillisEnumLiteralDeclaration_4() { return cToMillisEnumLiteralDeclaration_4; }

		//"toMillis"
		public Keyword getToMillisToMillisKeyword_4_0() { return cToMillisToMillisKeyword_4_0; }

		//// rounds a Number to an Integer
		//round
		public EnumLiteralDeclaration getRoundEnumLiteralDeclaration_5() { return cRoundEnumLiteralDeclaration_5; }

		//"round"
		public Keyword getRoundRoundKeyword_5_0() { return cRoundRoundKeyword_5_0; }

		//// sort a list
		//sort
		public EnumLiteralDeclaration getSortEnumLiteralDeclaration_6() { return cSortEnumLiteralDeclaration_6; }

		//"sort"
		public Keyword getSortSortKeyword_6_0() { return cSortSortKeyword_6_0; }

		//// validates some simple-typed lhs'es
		//isValid
		public EnumLiteralDeclaration getIsValidEnumLiteralDeclaration_7() { return cIsValidEnumLiteralDeclaration_7; }

		//"isValid"
		public Keyword getIsValidIsValidKeyword_7_0() { return cIsValidIsValidKeyword_7_0; }

		//// retrieves the (internal, generated) id of a structure as String
		//id
		public EnumLiteralDeclaration getIdEnumLiteralDeclaration_8() { return cIdEnumLiteralDeclaration_8; }

		//"id"
		public Keyword getIdIdKeyword_8_0() { return cIdIdKeyword_8_0; }
	}

	public class BooleanLiteralsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiterals");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cFalseEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cFalseFalseKeyword_0_0 = (Keyword)cFalseEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cTrueEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cTrueTrueKeyword_1_0 = (Keyword)cTrueEnumLiteralDeclaration_1.eContents().get(0);
		
		//// Note that the decimal part is required.
		//// TODO  fix problem with "negative" decimal part
		//enum BooleanLiterals:
		//	false / * default * / | true;
		public EnumRule getRule() { return rule; }

		//false / * default * / | true
		public Alternatives getAlternatives() { return cAlternatives; }

		//false
		public EnumLiteralDeclaration getFalseEnumLiteralDeclaration_0() { return cFalseEnumLiteralDeclaration_0; }

		//"false"
		public Keyword getFalseFalseKeyword_0_0() { return cFalseFalseKeyword_0_0; }

		//true
		public EnumLiteralDeclaration getTrueEnumLiteralDeclaration_1() { return cTrueEnumLiteralDeclaration_1; }

		//"true"
		public Keyword getTrueTrueKeyword_1_0() { return cTrueTrueKeyword_1_0; }
	}
	
	private UiModuleElements pUiModule;
	private TopLevelDefinitionElements pTopLevelDefinition;
	private TableRowsDefinitionElements pTableRowsDefinition;
	private ViewableElements pViewable;
	private DefinedViewableElements pDefinedViewable;
	private ManualViewableElements pManualViewable;
	private QualifiedNameElements pQualifiedName;
	private LocalViewableDefinitionElements pLocalViewableDefinition;
	private ViewableTypesElements unknownRuleViewableTypes;
	private ValuesBlockElements pValuesBlock;
	private ValueDeclarationElements pValueDeclaration;
	private ValueTypesElements unknownRuleValueTypes;
	private ValueElements pValue;
	private AbstractValueDeclarationElements pAbstractValueDeclaration;
	private ParameterElements pParameter;
	private ParameterListElements pParameterList;
	private MethodDefinitionElements pMethodDefinition;
	private MethodElements pMethod;
	private ElementElements pElement;
	private QuotationElements pQuotation;
	private BindingElements pBinding;
	private ElementBodyElements pElementBody;
	private ComponentInvocationElements pComponentInvocation;
	private ArgumentElements pArgument;
	private ArgumentListElements pArgumentList;
	private InputElementElements pInputElement;
	private RadioOptionElements pRadioOption;
	private StructureOptionElements pStructureOption;
	private ButtonElementElements pButtonElement;
	private BlockElementElements pBlockElement;
	private ListElementElements pListElement;
	private ListVariableElements pListVariable;
	private TableElementElements pTableElement;
	private TableBodyElementElements pTableBodyElement;
	private TableRowsInvocationElements pTableRowsInvocation;
	private TableRowElements pTableRow;
	private LabeledTableElementElements pLabeledTableElement;
	private LabeledTableRowElements pLabeledTableRow;
	private ProgressBarTabSetElements pProgressBarTabSet;
	private TabDeclarationElements pTabDeclaration;
	private GroupElementElements pGroupElement;
	private GroupOrientationsElements unknownRuleGroupOrientations;
	private VerticalAlignmentElements unknownRuleVerticalAlignment;
	private CountdownTimerElements pCountdownTimer;
	private ObserveElementElements pObserveElement;
	private CalendarElementElements pCalendarElement;
	private TimeSlotListElementElements pTimeSlotListElement;
	private SlotAddElementElements pSlotAddElement;
	private WhenElementElements pWhenElement;
	private ImageElementElements pImageElement;
	private FrameElementElements pFrameElement;
	private LineBreakElementElements pLineBreakElement;
	private StatementBlockElements pStatementBlock;
	private StatementElements pStatement;
	private ExitingStatementElements pExitingStatement;
	private NonExitingStatementElements pNonExitingStatement;
	private ForStatementElements pForStatement;
	private ListRemoveStatementElements pListRemoveStatement;
	private AssignmentOrExpressionStatementElements pAssignmentOrExpressionStatement;
	private AssignmentOperatorElements unknownRuleAssignmentOperator;
	private ShowModalStatementElements pShowModalStatement;
	private ExitModalStatementElements pExitModalStatement;
	private GotoScreenStatementElements pGotoScreenStatement;
	private GotoModuleStatementElements pGotoModuleStatement;
	private PrincipalArgumentElements pPrincipalArgument;
	private CredentialArgumentElements pCredentialArgument;
	private IfStatementElements pIfStatement;
	private LocalValueDeclarationStatementElements pLocalValueDeclarationStatement;
	private ViewableCallSiteElements pViewableCallSite;
	private ExpressionElements pExpression;
	private TernaryExpressionElements pTernaryExpression;
	private OrExpressionElements pOrExpression;
	private AndExpressionElements pAndExpression;
	private ComparisonExpressionElements pComparisonExpression;
	private ComparatorElements unknownRuleComparator;
	private AdditiveExpressionElements pAdditiveExpression;
	private AdditiveOperatorsElements unknownRuleAdditiveOperators;
	private MultiplicativeExpressionElements pMultiplicativeExpression;
	private MultiplicativeOperatorsElements unknownRuleMultiplicativeOperators;
	private NotExpressionElements pNotExpression;
	private InterfaceCallExpressionElements pInterfaceCallExpression;
	private ServiceIdentificationElements pServiceIdentification;
	private CrudTypesElements unknownRuleCrudTypes;
	private FeatureAccessExpressionElements pFeatureAccessExpression;
	private PrimaryExpressionElements pPrimaryExpression;
	private DateExpressionElements pDateExpression;
	private BuiltinFunctionExpressionElements pBuiltinFunctionExpression;
	private BuiltinFunctionsElements unknownRuleBuiltinFunctions;
	private LiteralExpressionElements pLiteralExpression;
	private ListLiteralExpressionElements pListLiteralExpression;
	private EnumerationLiteralExpressionElements pEnumerationLiteralExpression;
	private TerminalRule tINT;
	private NumberLiteralElements pNumberLiteral;
	private BooleanLiteralsElements unknownRuleBooleanLiterals;
	private DecisionExpressionElements pDecisionExpression;
	private DecisionCaseElements pDecisionCase;
	private CallbackExpressionsElements pCallbackExpressions;
	private CallbackExpressionElements pCallbackExpression;
	private StructureCreationExpressionElements pStructureCreationExpression;
	private FeatureAssignmentElements pFeatureAssignment;
	private ValueReferenceOrMethodCallExpressionElements pValueReferenceOrMethodCallExpression;
	private ReferenceExpressionElements pReferenceExpression;
	private ReferableElements pReferable;
	
	private final Grammar grammar;

	private SimStructureDslGrammarAccess gaSimStructureDsl;

	@Inject
	public SimUiDslGrammarAccess(GrammarProvider grammarProvider,
		SimStructureDslGrammarAccess gaSimStructureDsl) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaSimStructureDsl = gaSimStructureDsl;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("nl.dslmeinte.simscript.ui.SimUiDsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public SimStructureDslGrammarAccess getSimStructureDslGrammarAccess() {
		return gaSimStructureDsl;
	}

	
	/// **
	// * General Dependencies/Assumptions:
	// * 1.)	All widgets need framework js code (which should also be included in the HTML file) to work.
	// * / / *
	// * +------------+
	// * | structural |
	// * +------------+
	// * / UiModule:
	//	{UiModule} "ui-module" notAuthenticated?="not-authenticated"? definitions+=TopLevelDefinition*;
	public UiModuleElements getUiModuleAccess() {
		return (pUiModule != null) ? pUiModule : (pUiModule = new UiModuleElements());
	}
	
	public ParserRule getUiModuleRule() {
		return getUiModuleAccess().getRule();
	}

	//// TODO  consider adding "module globals" such as (immutable) parameters and error handling
	/// *
	//	 * validation:
	//	 * 	the first screen of a module should not take any parameters, or the GotoModuleStatement should have arguments
	//	 * / TopLevelDefinition:
	//	Viewable | TableRowsDefinition | MethodDefinition;
	public TopLevelDefinitionElements getTopLevelDefinitionAccess() {
		return (pTopLevelDefinition != null) ? pTopLevelDefinition : (pTopLevelDefinition = new TopLevelDefinitionElements());
	}
	
	public ParserRule getTopLevelDefinitionRule() {
		return getTopLevelDefinitionAccess().getRule();
	}

	//TableRowsDefinition:
	//	"table-rows" name=ID parameterList=ParameterList "{" rows+=TableRow* "}";
	public TableRowsDefinitionElements getTableRowsDefinitionAccess() {
		return (pTableRowsDefinition != null) ? pTableRowsDefinition : (pTableRowsDefinition = new TableRowsDefinitionElements());
	}
	
	public ParserRule getTableRowsDefinitionRule() {
		return getTableRowsDefinitionAccess().getRule();
	}

	//Viewable:
	//	DefinedViewable | ManualViewable;
	public ViewableElements getViewableAccess() {
		return (pViewable != null) ? pViewable : (pViewable = new ViewableElements());
	}
	
	public ParserRule getViewableRule() {
		return getViewableAccess().getRule();
	}

	//// derived feature: =screen(Viewable it) ::= type == _screen_	[√]
	//// pulled-up features: type, name, parameterList
	//DefinedViewable:
	//	type=ViewableTypes name=ID parameterList=ParameterList "{" // (feature's value may be null)
	//	valuesBlock=ValuesBlock? // (feature's value is always non-null)
	//	definitions+=LocalViewableDefinition* "}";
	public DefinedViewableElements getDefinedViewableAccess() {
		return (pDefinedViewable != null) ? pDefinedViewable : (pDefinedViewable = new DefinedViewableElements());
	}
	
	public ParserRule getDefinedViewableRule() {
		return getDefinedViewableAccess().getRule();
	}

	//// validation: warning in case of 0 elements					[√]
	//// derived feature: =screen(Viewable it) ::= type == _screen_	[√]
	/// *
	//	 * TODO  consider making a modal a separate viewable type
	//	 * The idea is that a modal should often be able to act as a confirm or an obligatory
	//	 * choice between a few actions in a way that's quite functional - e.g., persistent dialog box.
	//	 * / ManualViewable:
	//	"manual" type=ViewableTypes name=ID parameterList=ParameterList "in" namespace=QualifiedName;
	public ManualViewableElements getManualViewableAccess() {
		return (pManualViewable != null) ? pManualViewable : (pManualViewable = new ManualViewableElements());
	}
	
	public ParserRule getManualViewableRule() {
		return getManualViewableAccess().getRule();
	}

	//QualifiedName:
	//	ID ("." ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return (pQualifiedName != null) ? pQualifiedName : (pQualifiedName = new QualifiedNameElements());
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}

	//LocalViewableDefinition:
	//	Element | MethodDefinition;
	public LocalViewableDefinitionElements getLocalViewableDefinitionAccess() {
		return (pLocalViewableDefinition != null) ? pLocalViewableDefinition : (pLocalViewableDefinition = new LocalViewableDefinitionElements());
	}
	
	public ParserRule getLocalViewableDefinitionRule() {
		return getLocalViewableDefinitionAccess().getRule();
	}

	//enum ViewableTypes:
	//	screen | component;
	public ViewableTypesElements getViewableTypesAccess() {
		return (unknownRuleViewableTypes != null) ? unknownRuleViewableTypes : (unknownRuleViewableTypes = new ViewableTypesElements());
	}
	
	public EnumRule getViewableTypesRule() {
		return getViewableTypesAccess().getRule();
	}

	//ValuesBlock:
	//	{ValuesBlock} "values" "{" declarations+=ValueDeclaration* "}";
	public ValuesBlockElements getValuesBlockAccess() {
		return (pValuesBlock != null) ? pValuesBlock : (pValuesBlock = new ValuesBlockElements());
	}
	
	public ParserRule getValuesBlockRule() {
		return getValuesBlockAccess().getRule();
	}

	//ValueDeclaration:
	//	value=Value (":" declaredType=TypeLiteral)? (valueType=ValueTypes valueExpr=Expression)?;
	public ValueDeclarationElements getValueDeclarationAccess() {
		return (pValueDeclaration != null) ? pValueDeclaration : (pValueDeclaration = new ValueDeclarationElements());
	}
	
	public ParserRule getValueDeclarationRule() {
		return getValueDeclarationAccess().getRule();
	}

	//// validation: either the type, the value or both must be declared, must match and the value should be observable	[√]
	//// (TODO  straighten spec out)
	//enum ValueTypes:
	//	variable="=" | derived="<-";
	public ValueTypesElements getValueTypesAccess() {
		return (unknownRuleValueTypes != null) ? unknownRuleValueTypes : (unknownRuleValueTypes = new ValueTypesElements());
	}
	
	public EnumRule getValueTypesRule() {
		return getValueTypesAccess().getRule();
	}

	//Value:
	//	name=ID;
	public ValueElements getValueAccess() {
		return (pValue != null) ? pValue : (pValue = new ValueElements());
	}
	
	public ParserRule getValueRule() {
		return getValueAccess().getRule();
	}

	//// (synthetic convenience type)
	//AbstractValueDeclaration:
	//	ValueDeclaration | LocalValueDeclarationStatement;
	public AbstractValueDeclarationElements getAbstractValueDeclarationAccess() {
		return (pAbstractValueDeclaration != null) ? pAbstractValueDeclaration : (pAbstractValueDeclaration = new AbstractValueDeclarationElements());
	}
	
	public ParserRule getAbstractValueDeclarationRule() {
		return getAbstractValueDeclarationAccess().getRule();
	}

	//// validation: ( declaredType == null ) || declaredType.isAssignableFrom(valueExpr.type)	[√]
	//Parameter:
	//	name=ID ":" type=TypeLiteral;
	public ParameterElements getParameterAccess() {
		return (pParameter != null) ? pParameter : (pParameter = new ParameterElements());
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}

	//ParameterList:
	//	{ParameterList} "(" (parameters+=Parameter (("," | "|") parameters+=Parameter)*)? ","? ")";
	public ParameterListElements getParameterListAccess() {
		return (pParameterList != null) ? pParameterList : (pParameterList = new ParameterListElements());
	}
	
	public ParserRule getParameterListRule() {
		return getParameterListAccess().getRule();
	}

	/// *
	//	 * Note: you can either use commas or pipes to separate parameters and you
	//	 * 			can optionally have a non-separating, trailing comma.
	//	 * 			(The intent is to prevent having a sense of implied ordering.)
	//	 * / MethodDefinition:
	//	"method" method=Method parameterList=ParameterList statementBlock=StatementBlock;
	public MethodDefinitionElements getMethodDefinitionAccess() {
		return (pMethodDefinition != null) ? pMethodDefinition : (pMethodDefinition = new MethodDefinitionElements());
	}
	
	public ParserRule getMethodDefinitionRule() {
		return getMethodDefinitionAccess().getRule();
	}

	/// *
	//	 * semantics:
	//	 * 		The return value of a method is simply the value of the (evaluation of the) last statement - and likewise for the return type.
	//	 * 		In most cases, the return value will be null and its type will be Void - a method is a function if that's not the case.
	//	 * 		(Note that there's no return statement which'd make the statement flow more difficult to understand and analyse.)
	//	 * / Method:
	//	name=ID;
	public MethodElements getMethodAccess() {
		return (pMethod != null) ? pMethod : (pMethod = new MethodElements());
	}
	
	public ParserRule getMethodRule() {
		return getMethodAccess().getRule();
	}

	/// *
	// * +----------+
	// * | elements |
	// * +----------+
	// * / Element:
	//	Quotation // structural elements:
	//	// other elements:
	//	| // value elements
	//	Binding | // embedding
	//	ComponentInvocation | BlockElement | ListElement | TableElement | LabeledTableElement | ProgressBarTabSet |
	//	GroupElement | WhenElement | InputElement | ButtonElement | CountdownTimer | CalendarElement | TimeSlotListElement |
	//	SlotAddElement | ImageElement | FrameElement | LineBreakElement | ObserveElement | LabeledTableRow;
	public ElementElements getElementAccess() {
		return (pElement != null) ? pElement : (pElement = new ElementElements());
	}
	
	public ParserRule getElementRule() {
		return getElementAccess().getRule();
	}

	//Quotation:
	//	path=Expression;
	public QuotationElements getQuotationAccess() {
		return (pQuotation != null) ? pQuotation : (pQuotation = new QuotationElements());
	}
	
	public ParserRule getQuotationRule() {
		return getQuotationAccess().getRule();
	}

	//Binding:
	//	"bind" "(" bindSite=Expression ")";
	public BindingElements getBindingAccess() {
		return (pBinding != null) ? pBinding : (pBinding = new BindingElements());
	}
	
	public ParserRule getBindingRule() {
		return getBindingAccess().getRule();
	}

	/// *
	//	 * validation: bindSite.type must be observable		[√]
	//	 * semantics: indicates a reactive expression
	//	 * / ElementBody:
	//	{ElementBody} "{" elements+=Element* "}";
	public ElementBodyElements getElementBodyAccess() {
		return (pElementBody != null) ? pElementBody : (pElementBody = new ElementBodyElements());
	}
	
	public ParserRule getElementBodyRule() {
		return getElementBodyAccess().getRule();
	}

	//// validation: warning if elements.empty			[√]
	//ComponentInvocation:
	//	"embed" viewable=[Viewable] argumentList=ArgumentList;
	public ComponentInvocationElements getComponentInvocationAccess() {
		return (pComponentInvocation != null) ? pComponentInvocation : (pComponentInvocation = new ComponentInvocationElements());
	}
	
	public ParserRule getComponentInvocationRule() {
		return getComponentInvocationAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 * 		1-  viewable is a component																		[√]
	//	 * 		2-  all parameters of the viewable are covered by the arguments (and not more than once)		[√]
	//	 * workaround: prefixed with 'embed' to avoid parsing clash
	//	 * / // TODO  considering combining the previous 2 rules by creating a method call operator in the expressions language (&c.) - and get rid of 'embed'
	//Argument:
	//	parameter=[Parameter] "=" valueExpr=Expression;
	public ArgumentElements getArgumentAccess() {
		return (pArgument != null) ? pArgument : (pArgument = new ArgumentElements());
	}
	
	public ParserRule getArgumentRule() {
		return getArgumentAccess().getRule();
	}

	/// *
	//	 * scoping: parameter in containing(ComponentInvocation).viewable	[√]
	//	 * validation: parameter.type.isAssignableFrom(valueExpr.type)		[√]
	//	 * 
	//	 * Note that arguments are named, so there's no dependency on parameter order!
	//	 * / ArgumentList:
	//	{ArgumentList} "(" (arguments+=Argument (","? arguments+=Argument)* ","?)? ")";
	public ArgumentListElements getArgumentListAccess() {
		return (pArgumentList != null) ? pArgumentList : (pArgumentList = new ArgumentListElements());
	}
	
	public ParserRule getArgumentListRule() {
		return getArgumentListAccess().getRule();
	}

	/// *
	//	 * The commas are optional - for now, I might remove them later on. In the meanwhile,
	//	 * you can have a non-separating, trailing comma as well.
	//	 * 
	//	 * The reason is that whitespace tends to be provide sufficient visual separation
	//	 * and the '=' character sufficient visual binding. Also, commas have a connotation
	//	 * of implied ordering which is irrelevant here.
	//	 * / InputElement:
	//	"input" "(" bindSite=Expression (("hint" "=" hint=STRING)? // event is fired when value is changed and input field looses focus
	//	// event is fired when Enter is pressed and input is valid
	//	& ("min" "=" minValue=Expression)? & ("max" "=" maxValue=Expression)? & radioOption=RadioOption? & ("onChange" "="
	//	onChange=Expression)? & ("onSubmit" "=" onSubmit=Expression)? & structureOption=StructureOption?) ")";
	public InputElementElements getInputElementAccess() {
		return (pInputElement != null) ? pInputElement : (pInputElement = new InputElementElements());
	}
	
	public ParserRule getInputElementRule() {
		return getInputElementAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 * 		1-  bindSite must be a proper target/valid left-hand side			[√]
	//	 * 		2-	bindSite must not be a callback- or void-typed 					[√]
	//	 * 		x-  warning given for types on which hint is not supported			[√]
	//	 * 		3-  min/max only allowed if bindSite is numerically-typed			[√]
	//	 * 		4-	min&max must be numerically-typed								[√]
	//	 * 		5-  radioOption can only be given if bindSite is boolean-typed		[√]
	//	 * 		6-  onChange.type == Callback										[√]
	//	 * 		y-  warning given for unsupported onChange option					[√]
	//	 * 		7-  structure option required <==> input is structure-typed 		[√]
	//	 * 		8-  warning given for (potentially) uninitialized enum fields		[ ]		TODO  OR fix FIXME in JS framework/widgets code
	//	 * 		9-  onSumbit.type == Callback										[√]
	//	 * / // semantics: corresponds to an HTML input element, with the hint being given for (at least) textually-typed fields
	//// TODO  add length option (which is supported by some of the widgets)?
	//RadioOption:
	//	"radio" "=" "{" true=STRING "/" false=STRING "}";
	public RadioOptionElements getRadioOptionAccess() {
		return (pRadioOption != null) ? pRadioOption : (pRadioOption = new RadioOptionElements());
	}
	
	public ParserRule getRadioOptionRule() {
		return getRadioOptionAccess().getRule();
	}

	//StructureOption:
	//	"source" "=" "{" sourceExpr=Expression "->" displayFunction=[Method] "}";
	public StructureOptionElements getStructureOptionAccess() {
		return (pStructureOption != null) ? pStructureOption : (pStructureOption = new StructureOptionElements());
	}
	
	public ParserRule getStructureOptionRule() {
		return getStructureOptionAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 * 		1-  source must be list-typed with structure type as item type		[√]
	//	 * 		2-  displayFunction must refer a function of signature
	//	 * 				(bindSite.type.listItemType) -> String (i.e., a closure)	[√]
	//	 * / ButtonElement:
	//	"button" "(" ("text" "=" text=STRING & "onClick" "=" action=Expression & ("class" "=" cssClass=STRING)?) ")";
	public ButtonElementElements getButtonElementAccess() {
		return (pButtonElement != null) ? pButtonElement : (pButtonElement = new ButtonElementElements());
	}
	
	public ParserRule getButtonElementRule() {
		return getButtonElementAccess().getRule();
	}

	/// *
	//	 * validation: action.type == Callback				[√]
	//	 * design decision: `action` needs to be an Expression because we want to be able to refer to passed callbacks (and such)
	//	 * / BlockElement:
	//	"block" "(" (("onClick" "=" onClick=Expression)? & ("class" "=" cssClass=STRING)? & ("bodyClass" "="
	//	bodyCssClass=STRING)? & ("style" "=" style=STRING)? & ("header" "=" header=ElementBody)? & ("headerClass" "="
	//	headerCssClass=STRING)? & noCss?="noCss"?) ")" body=ElementBody;
	public BlockElementElements getBlockElementAccess() {
		return (pBlockElement != null) ? pBlockElement : (pBlockElement = new BlockElementElements());
	}
	
	public ParserRule getBlockElementRule() {
		return getBlockElementAccess().getRule();
	}

	/// *
	//	 * validation: onClick.type == Callback				[√] 
	//	 * / ListElement:
	//	"list" "(" "(" indexVariable=ListVariable "->" valueVariable=ListVariable ")" "in" listExpression=Expression ")"
	//	body=ElementBody;
	public ListElementElements getListElementAccess() {
		return (pListElement != null) ? pListElement : (pListElement = new ListElementElements());
	}
	
	public ParserRule getListElementRule() {
		return getListElementAccess().getRule();
	}

	//// validation: listExpression.type.arrayTyped		[√]
	//// TODO  add element that serves as a deletion mechanism
	//ListVariable:
	//	name=ID;
	public ListVariableElements getListVariableAccess() {
		return (pListVariable != null) ? pListVariable : (pListVariable = new ListVariableElements());
	}
	
	public ParserRule getListVariableRule() {
		return getListVariableAccess().getRule();
	}

	//TableElement:
	//	{TableElement} "table" "{" subElements+=TableBodyElement* "}";
	public TableElementElements getTableElementAccess() {
		return (pTableElement != null) ? pTableElement : (pTableElement = new TableElementElements());
	}
	
	public ParserRule getTableElementRule() {
		return getTableElementAccess().getRule();
	}

	//// validation: warning if subElements.empty								[√]
	//TableBodyElement:
	//	TableRow | TableRowsInvocation;
	public TableBodyElementElements getTableBodyElementAccess() {
		return (pTableBodyElement != null) ? pTableBodyElement : (pTableBodyElement = new TableBodyElementElements());
	}
	
	public ParserRule getTableBodyElementRule() {
		return getTableBodyElementAccess().getRule();
	}

	//TableRowsInvocation:
	//	"embed" definition=[TableRowsDefinition] argumentList=ArgumentList;
	public TableRowsInvocationElements getTableRowsInvocationAccess() {
		return (pTableRowsInvocation != null) ? pTableRowsInvocation : (pTableRowsInvocation = new TableRowsInvocationElements());
	}
	
	public ParserRule getTableRowsInvocationRule() {
		return getTableRowsInvocationAccess().getRule();
	}

	//TableRow:
	//	label=Expression body= // the implicit, quasi-non-LL(*) kind
	//	ElementBody;
	public TableRowElements getTableRowAccess() {
		return (pTableRow != null) ? pTableRow : (pTableRow = new TableRowElements());
	}
	
	public ParserRule getTableRowRule() {
		return getTableRowAccess().getRule();
	}

	//// validation: label.type = STRING										[√]
	//LabeledTableElement:
	//	{LabeledTableElement} "labeled-table" body=ElementBody;
	public LabeledTableElementElements getLabeledTableElementAccess() {
		return (pLabeledTableElement != null) ? pLabeledTableElement : (pLabeledTableElement = new LabeledTableElementElements());
	}
	
	public ParserRule getLabeledTableElementRule() {
		return getLabeledTableElementAccess().getRule();
	}

	//// validate: all directly-contained, non-structural elements are a LabeledTableRow	[√]
	//LabeledTableRow:
	//	"label" "=" label=Expression body= // the explicit, LL(*) kind
	//	ElementBody;
	public LabeledTableRowElements getLabeledTableRowAccess() {
		return (pLabeledTableRow != null) ? pLabeledTableRow : (pLabeledTableRow = new LabeledTableRowElements());
	}
	
	public ParserRule getLabeledTableRowRule() {
		return getLabeledTableRowAccess().getRule();
	}

	//// validation: label.type = STRING										[√]
	//ProgressBarTabSet:
	//	{ProgressBarTabSet} "progressBarTabSet" "(" tabs+=TabDeclaration* ")";
	public ProgressBarTabSetElements getProgressBarTabSetAccess() {
		return (pProgressBarTabSet != null) ? pProgressBarTabSet : (pProgressBarTabSet = new ProgressBarTabSetElements());
	}
	
	public ParserRule getProgressBarTabSetRule() {
		return getProgressBarTabSetAccess().getRule();
	}

	//// validation: warning if #tabs == 0				[√]
	//TabDeclaration:
	//	"{" ("header" "=" header=ElementBody) & "component" "=" viewable=[Viewable] argumentList=ArgumentList & ("previous"
	//	"=" previousCallback=CallbackExpression)? & ("next" "=" nextCallback=CallbackExpression)? "}";
	public TabDeclarationElements getTabDeclarationAccess() {
		return (pTabDeclaration != null) ? pTabDeclaration : (pTabDeclaration = new TabDeclarationElements());
	}
	
	public ParserRule getTabDeclarationRule() {
		return getTabDeclarationAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 * 		1-  title must be string-typed				[√]
	//	 * 		2-  viewable must be a component			[√]
	//	 * / // TODO  remove this construct as we seem to prefer using block-s with CSS
	//GroupElement:
	//	{GroupElement} "group" ("(" "orientation" "=" orientation=GroupOrientations ("v-align" "=" v_align=VerticalAlignment)?
	//	")")? "{" (nestedGroups+=GroupElement+ | leafGroups+=ElementBody+) "}";
	public GroupElementElements getGroupElementAccess() {
		return (pGroupElement != null) ? pGroupElement : (pGroupElement = new GroupElementElements());
	}
	
	public ParserRule getGroupElementRule() {
		return getGroupElementAccess().getRule();
	}

	/// *
	//	 * Note: alternatives have > 0 cardinality to avoid an ambiguity.
	//	 * (Haven't found out yet how to avoid that with a syntactic predicate...)
	//	 * / enum GroupOrientations:
	//	vertical | // vertical is default (1st literal)
	//	horizontal;
	public GroupOrientationsElements getGroupOrientationsAccess() {
		return (unknownRuleGroupOrientations != null) ? unknownRuleGroupOrientations : (unknownRuleGroupOrientations = new GroupOrientationsElements());
	}
	
	public EnumRule getGroupOrientationsRule() {
		return getGroupOrientationsAccess().getRule();
	}

	//enum VerticalAlignment:
	//	top | bottom | middle;
	public VerticalAlignmentElements getVerticalAlignmentAccess() {
		return (unknownRuleVerticalAlignment != null) ? unknownRuleVerticalAlignment : (unknownRuleVerticalAlignment = new VerticalAlignmentElements());
	}
	
	public EnumRule getVerticalAlignmentRule() {
		return getVerticalAlignmentAccess().getRule();
	}

	//CountdownTimer:
	//	"countdownTimer" "(" observed?="observe"? endTime=Expression ("onEnd" "=" onEnd=Expression)? ")";
	public CountdownTimerElements getCountdownTimerAccess() {
		return (pCountdownTimer != null) ? pCountdownTimer : (pCountdownTimer = new CountdownTimerElements());
	}
	
	public ParserRule getCountdownTimerRule() {
		return getCountdownTimerAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 *		1-  bindSite must be a proper target/valid left-hand side iff bound		[√]
	//	 * 		2-  onEnd.type == CallbackExpression iff onEnd != null					[√]
	//	 * / ObserveElement:
	//	"observe" observeExpr=Expression statementBlock=StatementBlock;
	public ObserveElementElements getObserveElementAccess() {
		return (pObserveElement != null) ? pObserveElement : (pObserveElement = new ObserveElementElements());
	}
	
	public ParserRule getObserveElementRule() {
		return getObserveElementAccess().getRule();
	}

	//// TODO  document precise semantics (and how is it different from a Binding e.g.)
	//CalendarElement:
	//	"calendar" "(" date=Expression (("onSelect" "=" onSelect=Expression)? & ("allowFrom" "=" allowFrom=Expression)? &
	//	("dateFormat" "=" dateFormat=STRING)? & ("cssForDays" "=" "(" "days" "=" days=Expression "," "class" "="
	//	cssClass=STRING ")")?) ")";
	public CalendarElementElements getCalendarElementAccess() {
		return (pCalendarElement != null) ? pCalendarElement : (pCalendarElement = new CalendarElementElements());
	}
	
	public ParserRule getCalendarElementRule() {
		return getCalendarElementAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 * 		1-  onSelect.type == CallbackExpression		[√]
	//	 * 		2-	allowFrom.type.dateTyped				[√]
	//	 * 		3-	date.type.dateTyped						[ ]
	//	 * 		4-  date.lhs???		TODO
	//	 * 		5-	days.type.listTyped						[ ]
	//	 * 		6-	days.type.listItemType.dateTyped		[ ]
	//	 * / TimeSlotListElement:
	//	"timeSlotList" "(" slots=Expression (("onSelect" "=" onSelect=Expression)? & ("onDelete" "=" onDelete=Expression)?)
	//	")";
	public TimeSlotListElementElements getTimeSlotListElementAccess() {
		return (pTimeSlotListElement != null) ? pTimeSlotListElement : (pTimeSlotListElement = new TimeSlotListElementElements());
	}
	
	public ParserRule getTimeSlotListElementRule() {
		return getTimeSlotListElementAccess().getRule();
	}

	/// * validation:
	//	 * 		1-	slots.type = [Slot]						[ ]
	//	 * / SlotAddElement:
	//	"slotAddList" "(" product=Expression day=Expression slots=Expression ("{" startHour=Expression "to" endHour=Expression
	//	"}")? ")";
	public SlotAddElementElements getSlotAddElementAccess() {
		return (pSlotAddElement != null) ? pSlotAddElement : (pSlotAddElement = new SlotAddElementElements());
	}
	
	public ParserRule getSlotAddElementRule() {
		return getSlotAddElementAccess().getRule();
	}

	//WhenElement:
	//	"when" "(" condition=Expression ")" body=ElementBody;
	public WhenElementElements getWhenElementAccess() {
		return (pWhenElement != null) ? pWhenElement : (pWhenElement = new WhenElementElements());
	}
	
	public ParserRule getWhenElementRule() {
		return getWhenElementAccess().getRule();
	}

	//// validation: condition.type.booleanTyped			[√]
	//ImageElement:
	//	"image" "(" (observed?="observe"? sourceUrl=Expression & ("width" "=" width=Expression)? & ("height" "="
	//	height=Expression)?) ")";
	public ImageElementElements getImageElementAccess() {
		return (pImageElement != null) ? pImageElement : (pImageElement = new ImageElementElements());
	}
	
	public ParserRule getImageElementRule() {
		return getImageElementAccess().getRule();
	}

	/// * 
	//	 * validation: source.type.stringTyped				[√]
	//	 * width and height should be Integer typed.		[ ]
	//	 * / // (not called 'IFrameElement' because of possible confusion with an interface)
	//FrameElement:
	//	"iframe" "(" sourceUrl=Expression (("width" "=" width=Expression)? & ("height" "=" height=Expression)?) ")";
	public FrameElementElements getFrameElementAccess() {
		return (pFrameElement != null) ? pFrameElement : (pFrameElement = new FrameElementElements());
	}
	
	public ParserRule getFrameElementRule() {
		return getFrameElementAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 * 		1-  sourceUrl.type.stringTyped				[√]
	//	 * 		2-	{width, height}.type.integerTyped		[√]
	//	 * / // TODO  make source URL observable?
	//LineBreakElement:
	//	{LineBreakElement} "line-break";
	public LineBreakElementElements getLineBreakElementAccess() {
		return (pLineBreakElement != null) ? pLineBreakElement : (pLineBreakElement = new LineBreakElementElements());
	}
	
	public ParserRule getLineBreakElementRule() {
		return getLineBreakElementAccess().getRule();
	}

	/// *
	// * +------------+
	// * | statements |
	// * +------------+
	// * / StatementBlock:
	//	{StatementBlock} "{" statements+=Statement* "}";
	public StatementBlockElements getStatementBlockAccess() {
		return (pStatementBlock != null) ? pStatementBlock : (pStatementBlock = new StatementBlockElements());
	}
	
	public ParserRule getStatementBlockRule() {
		return getStatementBlockAccess().getRule();
	}

	/// *
	//	 * validation:	warning if #statements == 0			[√]
	//	 * 
	//	 * A StatementBlock is contained by the following features:
	//	 * 		MethodDefinition.statementBlock
	//	 * 		CallbackExpression.statementBlock
	//	 * 		IfStatement.thenBlock
	//	 * 		IfStatement.elseBlock
	//	 * / // (synthetic type)
	//Statement:
	//	NonExitingStatement | ExitingStatement;
	public StatementElements getStatementAccess() {
		return (pStatement != null) ? pStatement : (pStatement = new StatementElements());
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//// A Statement is always contained in a StatementBlock.
	//ExitingStatement:
	//	GotoScreenStatement | GotoModuleStatement;
	public ExitingStatementElements getExitingStatementAccess() {
		return (pExitingStatement != null) ? pExitingStatement : (pExitingStatement = new ExitingStatementElements());
	}
	
	public ParserRule getExitingStatementRule() {
		return getExitingStatementAccess().getRule();
	}

	//NonExitingStatement:
	//	AssignmentOrExpressionStatement | ShowModalStatement | ExitModalStatement | IfStatement |
	//	LocalValueDeclarationStatement | ListRemoveStatement | ForStatement;
	public NonExitingStatementElements getNonExitingStatementAccess() {
		return (pNonExitingStatement != null) ? pNonExitingStatement : (pNonExitingStatement = new NonExitingStatementElements());
	}
	
	public ParserRule getNonExitingStatementRule() {
		return getNonExitingStatementAccess().getRule();
	}

	//ForStatement:
	//	"for" "(" "(" indexVariable=ListVariable "->" valueVariable=ListVariable ")" "in" listExpression=Expression ")"
	//	thenBlock=StatementBlock;
	public ForStatementElements getForStatementAccess() {
		return (pForStatement != null) ? pForStatement : (pForStatement = new ForStatementElements());
	}
	
	public ParserRule getForStatementRule() {
		return getForStatementAccess().getRule();
	}

	//ListRemoveStatement:
	//	"remove" "from" listExpr=Expression ("where" feature=[struct::Feature] "==" valueExpr=Expression | "at"
	//	indexVariable=Expression);
	public ListRemoveStatementElements getListRemoveStatementAccess() {
		return (pListRemoveStatement != null) ? pListRemoveStatement : (pListRemoveStatement = new ListRemoveStatementElements());
	}
	
	public ParserRule getListRemoveStatementRule() {
		return getListRemoveStatementAccess().getRule();
	}

	/// *
	//	 * scoping: feature in listExpr.type.listItemType.structure.features			[√]
	//	 * validation:
	//	 * 		1-  listExpr.type = [Structure]											[√]
	//	 * 		2-  if feature != null: feature.type.isAssignableFrom(valueExpr.type)	[√]
	//	 * / AssignmentOrExpressionStatement:
	//	lhs=Expression (operator=AssignmentOperator rhs=Expression)?;
	public AssignmentOrExpressionStatementElements getAssignmentOrExpressionStatementAccess() {
		return (pAssignmentOrExpressionStatement != null) ? pAssignmentOrExpressionStatement : (pAssignmentOrExpressionStatement = new AssignmentOrExpressionStatementElements());
	}
	
	public ParserRule getAssignmentOrExpressionStatementRule() {
		return getAssignmentOrExpressionStatementAccess().getRule();
	}

	//// TODO  split out specification according to whether rhs is null and again for != null according to operator (assignment vs. the others)
	/// *
	//	 * validation:
	//	 * 		1-  lhs must be a valid left-hand side		[?]
	//	 * 		2-  lhs.type.isAssignableFrom(rhs.type)		[?]
	//	 * TODO  rework
	//	 * / / *
	//	 * This beasty has wildly differing semantics depending on whether it represents
	//	 * 		*) a assigment			<=> rhs != null		(can also be a sum assignment)
	//	 * 		*) a lone expression 	<=> rhs == null		(with some restrictions on the exact expression type)
	//	 * / // TODO  consider making this into an operator as sub type of Expression again - however, during last experiment this caused a lot of non-LL(*)-ness
	//enum AssignmentOperator:
	//	assign="=" | add="+=" | sub="-=";
	public AssignmentOperatorElements getAssignmentOperatorAccess() {
		return (unknownRuleAssignmentOperator != null) ? unknownRuleAssignmentOperator : (unknownRuleAssignmentOperator = new AssignmentOperatorElements());
	}
	
	public EnumRule getAssignmentOperatorRule() {
		return getAssignmentOperatorAccess().getRule();
	}

	//ShowModalStatement:
	//	"show-modal" viewable=[Viewable] argumentList=ArgumentList persistent?="persistent"?;
	public ShowModalStatementElements getShowModalStatementAccess() {
		return (pShowModalStatement != null) ? pShowModalStatement : (pShowModalStatement = new ShowModalStatementElements());
	}
	
	public ParserRule getShowModalStatementRule() {
		return getShowModalStatementAccess().getRule();
	}

	//ExitModalStatement:
	//	{ExitModalStatement} "exit-modal";
	public ExitModalStatementElements getExitModalStatementAccess() {
		return (pExitModalStatement != null) ? pExitModalStatement : (pExitModalStatement = new ExitModalStatementElements());
	}
	
	public ParserRule getExitModalStatementRule() {
		return getExitModalStatementAccess().getRule();
	}

	//GotoScreenStatement:
	//	("goto" | "goto-screen") viewable=[Viewable] => argumentList=ArgumentList;
	public GotoScreenStatementElements getGotoScreenStatementAccess() {
		return (pGotoScreenStatement != null) ? pGotoScreenStatement : (pGotoScreenStatement = new GotoScreenStatementElements());
	}
	
	public ParserRule getGotoScreenStatementRule() {
		return getGotoScreenStatementAccess().getRule();
	}

	//// scoping: viewable == all(Viewable)-in-this-resource.filter[screen]	[√]
	/// *
	//	 * Call syntax is now aligned with declaration syntax because '(..)' are required.
	//	 * / GotoModuleStatement:
	//	"goto-module" targetModule=[UiModule] args=ArgumentList / *
	//	 * (I'd rather use 'argumentList' instead 'args' but that triggers
	//	 * the duplicate feature validation of Xtext - whether that's incorrect or not.)
	//	 * / (authenticate?="after-authentication-by" authOption=[backend::AuthenticationDeclaration] "("
	//	principal=PrincipalArgument "," credential=CredentialArgument ")" "@error:" errorCallback=CallbackExpression)?;
	public GotoModuleStatementElements getGotoModuleStatementAccess() {
		return (pGotoModuleStatement != null) ? pGotoModuleStatement : (pGotoModuleStatement = new GotoModuleStatementElements());
	}
	
	public ParserRule getGotoModuleStatementRule() {
		return getGotoModuleStatementAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 * 		1-  principals contains all principals of authOption.principals		[V]
	//	 * 		2-	credentials contains all credentials of authOption.credentials	[V]
	//	 * / PrincipalArgument:
	//	principal=[backend::AuthenticationParameter] "=" valueExpr=Expression;
	public PrincipalArgumentElements getPrincipalArgumentAccess() {
		return (pPrincipalArgument != null) ? pPrincipalArgument : (pPrincipalArgument = new PrincipalArgumentElements());
	}
	
	public ParserRule getPrincipalArgumentRule() {
		return getPrincipalArgumentAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 * 		principal.type.isAssignableFrom(valueExpr.type)						[V]
	//	 * 
	//	 * scoping:
	//	 * 		principal in containerHaving(typeof GotoModuleStatement).authOption.principals
	//	 * / CredentialArgument:
	//	credential=[backend::AuthenticationParameter] "=" valueExpr=Expression;
	public CredentialArgumentElements getCredentialArgumentAccess() {
		return (pCredentialArgument != null) ? pCredentialArgument : (pCredentialArgument = new CredentialArgumentElements());
	}
	
	public ParserRule getCredentialArgumentRule() {
		return getCredentialArgumentAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 * 		credential.type.isAssignableFrom(valueExpr.type)					[V]
	//	 * 
	//	 * scoping:
	//	 * 		credential in containerHaving(typeof GotoModuleStatement).authOption.credentials
	//	 * / IfStatement:
	//	"if" "(" condition=Expression ")" thenBlock=StatementBlock ("else" elseBlock=StatementBlock)?;
	public IfStatementElements getIfStatementAccess() {
		return (pIfStatement != null) ? pIfStatement : (pIfStatement = new IfStatementElements());
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 *		1-  condition must be boolean-typed								[√]
	//	 * 		2-  thenBlock.type.isAssignableFrom(elseBlock.type)				[√]
	//	 * / LocalValueDeclarationStatement:
	//	"val" value=Value (":" declaredType=TypeLiteral)? "=" valueExpr=Expression;
	public LocalValueDeclarationStatementElements getLocalValueDeclarationStatementAccess() {
		return (pLocalValueDeclarationStatement != null) ? pLocalValueDeclarationStatement : (pLocalValueDeclarationStatement = new LocalValueDeclarationStatementElements());
	}
	
	public ParserRule getLocalValueDeclarationStatementRule() {
		return getLocalValueDeclarationStatementAccess().getRule();
	}

	//// (synthetic type)
	//ViewableCallSite:
	//	GotoScreenStatement | ComponentInvocation | TabDeclaration | ShowModalStatement;
	public ViewableCallSiteElements getViewableCallSiteAccess() {
		return (pViewableCallSite != null) ? pViewableCallSite : (pViewableCallSite = new ViewableCallSiteElements());
	}
	
	public ParserRule getViewableCallSiteRule() {
		return getViewableCallSiteAccess().getRule();
	}

	//// validation: arguments are checked against viewable.parameters for unmapped and duplicately-mapped parameters		[√]
	/// *
	// * +-------------+
	// * | expressions |
	// * +-------------+
	// * / Expression:
	//	TernaryExpression;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//TernaryExpression returns Expression:
	//	OrExpression ({TernaryExpression.guard=current} "?" thenExpr=OrExpression ":" elseExpr=OrExpression)?;
	public TernaryExpressionElements getTernaryExpressionAccess() {
		return (pTernaryExpression != null) ? pTernaryExpression : (pTernaryExpression = new TernaryExpressionElements());
	}
	
	public ParserRule getTernaryExpressionRule() {
		return getTernaryExpressionAccess().getRule();
	}

	/// * 
	//	 * validation:
	//	 * 		1-  guard must be boolean-typed						[√]
	//	 * 		2-  thenExpr and elseExpr must be type-compatible	[√]
	//	 * / OrExpression returns Expression:
	//	AndExpression ({OrExpression.leftOperand=current} "||" rightOperand=AndExpression)* // left-associative infix binary operator
	//;
	public OrExpressionElements getOrExpressionAccess() {
		return (pOrExpression != null) ? pOrExpression : (pOrExpression = new OrExpressionElements());
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}

	//// validation: leftOperand, rightOperand are Boolean-typed	[√]
	//AndExpression returns Expression:
	//	ComparisonExpression ({AndExpression.leftOperand=current} "&&" rightOperand=ComparisonExpression)* // left-associative infix binary operator
	//;
	public AndExpressionElements getAndExpressionAccess() {
		return (pAndExpression != null) ? pAndExpression : (pAndExpression = new AndExpressionElements());
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}

	//// validation: leftOperand, rightOperand are Boolean-typed	[√]
	//ComparisonExpression returns Expression:
	//	AdditiveExpression ({ComparisonExpression.leftOperand=current} comparator=Comparator rightOperand=AdditiveExpression)* // left-associative infix binary operator
	//;
	public ComparisonExpressionElements getComparisonExpressionAccess() {
		return (pComparisonExpression != null) ? pComparisonExpression : (pComparisonExpression = new ComparisonExpressionElements());
	}
	
	public ParserRule getComparisonExpressionRule() {
		return getComparisonExpressionAccess().getRule();
	}

	//// validation: leftOperand.type == rightOperand.type		[√]
	//enum Comparator:
	//	equals="==" | notEquals="!=" | bigger=">" | biggerEquals=">=" | smaller="<" | smallerEquals="<=" | isIn="in";
	public ComparatorElements getComparatorAccess() {
		return (unknownRuleComparator != null) ? unknownRuleComparator : (unknownRuleComparator = new ComparatorElements());
	}
	
	public EnumRule getComparatorRule() {
		return getComparatorAccess().getRule();
	}

	//AdditiveExpression returns Expression:
	//	MultiplicativeExpression ({AdditiveExpression.leftOperand=current} operator=AdditiveOperators
	//	rightOperand=MultiplicativeExpression)* // left-associative infix binary operator
	//;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return (pAdditiveExpression != null) ? pAdditiveExpression : (pAdditiveExpression = new AdditiveExpressionElements());
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}

	//// validation: leftOperand, rightOperand must be numerically-typed	[√]
	//enum AdditiveOperators:
	//	plus="+" | minus="-";
	public AdditiveOperatorsElements getAdditiveOperatorsAccess() {
		return (unknownRuleAdditiveOperators != null) ? unknownRuleAdditiveOperators : (unknownRuleAdditiveOperators = new AdditiveOperatorsElements());
	}
	
	public EnumRule getAdditiveOperatorsRule() {
		return getAdditiveOperatorsAccess().getRule();
	}

	//// TODO  overload the + to handle array types as well
	//MultiplicativeExpression returns Expression:
	//	NotExpression ({MultiplicativeExpression.leftOperand=current} operator=MultiplicativeOperators
	//	rightOperand=NotExpression)* // left-associative infix binary operator
	//;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return (pMultiplicativeExpression != null) ? pMultiplicativeExpression : (pMultiplicativeExpression = new MultiplicativeExpressionElements());
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}

	//// validation: leftOperand, rightOperand must be numerically-typed	[√]
	//enum MultiplicativeOperators:
	//	mult="*" | div="/" | mod="%";
	public MultiplicativeOperatorsElements getMultiplicativeOperatorsAccess() {
		return (unknownRuleMultiplicativeOperators != null) ? unknownRuleMultiplicativeOperators : (unknownRuleMultiplicativeOperators = new MultiplicativeOperatorsElements());
	}
	
	public EnumRule getMultiplicativeOperatorsRule() {
		return getMultiplicativeOperatorsAccess().getRule();
	}

	//NotExpression returns Expression:
	//	InterfaceCallExpression | {NotExpression} "!" operand=NotExpression;
	public NotExpressionElements getNotExpressionAccess() {
		return (pNotExpression != null) ? pNotExpression : (pNotExpression = new NotExpressionElements());
	}
	
	public ParserRule getNotExpressionRule() {
		return getNotExpressionAccess().getRule();
	}

	//// validation: operand.type.booleanTyped							[√]
	//InterfaceCallExpression returns Expression:
	//	FeatureAccessExpression | {InterfaceCallExpression} "call" serviceId=ServiceIdentification "(" ("observe" "["
	//	observeSites+=Expression* "]")? input=Expression? ")" ("=>" callback=CallbackExpression ("@error:"
	//	errorCallback=CallbackExpression)?)?;
	public InterfaceCallExpressionElements getInterfaceCallExpressionAccess() {
		return (pInterfaceCallExpression != null) ? pInterfaceCallExpression : (pInterfaceCallExpression = new InterfaceCallExpressionElements());
	}
	
	public ParserRule getInterfaceCallExpressionRule() {
		return getInterfaceCallExpressionAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 * 		1-  serviceId.inputType.isAssignableFrom(input.type)																		[√]
	//	 * 		2-  InterfaceCallExpression can only be a lone expression as a statement or the initialisation of a value declaration		[√]
	//	 * / // TODO  more validation? e.g. callback and observeSites are "often" illegal
	//ServiceIdentification:
	//	{NamedServiceReference} service=[backend::NamedService] | {CrudServiceIdentification} crudType=CrudTypes
	//	structure=[struct::Structure];
	public ServiceIdentificationElements getServiceIdentificationAccess() {
		return (pServiceIdentification != null) ? pServiceIdentification : (pServiceIdentification = new ServiceIdentificationElements());
	}
	
	public ParserRule getServiceIdentificationRule() {
		return getServiceIdentificationAccess().getRule();
	}

	//// validation: check that a used CrudService(Identification) is actually declared somewhere		[ ]
	/// *
	//	 * Note: that condition is (somewhat) hard to check since .sim_back only have outgoing references
	//	 * and no incoming ones, so that they don't end up in the same ResourceSet as .sim_ui - at least,
	//	 * during normal editor usage.
	//	 * / // validation: serviceId."interface".inputType.isAssignableFrom(input.type)		[√]
	//// copied from SimScript-Backend DSL grammar:
	//enum CrudTypes:
	//	create | getById="get-by-id" | update | delete;
	public CrudTypesElements getCrudTypesAccess() {
		return (unknownRuleCrudTypes != null) ? unknownRuleCrudTypes : (unknownRuleCrudTypes = new CrudTypesElements());
	}
	
	public EnumRule getCrudTypesRule() {
		return getCrudTypesAccess().getRule();
	}

	//FeatureAccessExpression returns Expression hidden():
	//	PrimaryExpression ({FeatureAccessExpression.previous=current} "." feature=[struct::Feature])* // left-associative infix binary operator
	//;
	public FeatureAccessExpressionElements getFeatureAccessExpressionAccess() {
		return (pFeatureAccessExpression != null) ? pFeatureAccessExpression : (pFeatureAccessExpression = new FeatureAccessExpressionElements());
	}
	
	public ParserRule getFeatureAccessExpressionRule() {
		return getFeatureAccessExpressionAccess().getRule();
	}

	//// scoping: feature in previous.type.features												[√]
	//// validation: previous must be a FeatureAccessExpression or a ValueReferenceExpression		[√]
	//// TODO  add invocation of member methods and such
	//// TODO  use an enum BuiltinMemberFunctions to add "member calls" to FeatureAccessExpression (and add a ton of validation)
	//// (undo cascade of FeatureAccessExpression's hidden())
	//PrimaryExpression returns Expression hidden(WS, ML_COMMENT, SL_COMMENT):
	//	"(" Expression ")" | LiteralExpression | CallbackExpressions | StructureCreationExpression |
	//	ValueReferenceOrMethodCallExpression | DateExpression | BuiltinFunctionExpression | {SelectionExpression} "selection";
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return (pPrimaryExpression != null) ? pPrimaryExpression : (pPrimaryExpression = new PrimaryExpressionElements());
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//// validation: SelectionExpression may only be used within CalendarStatement.onSelect		[?]
	//DateExpression:
	//	{DateNowExpression} "now" | {DateTodayExpression} "today";
	public DateExpressionElements getDateExpressionAccess() {
		return (pDateExpression != null) ? pDateExpression : (pDateExpression = new DateExpressionElements());
	}
	
	public ParserRule getDateExpressionRule() {
		return getDateExpressionAccess().getRule();
	}

	//BuiltinFunctionExpression:
	//	function=BuiltinFunctions "(" argument=Expression ("on" sortFeature=[struct::Feature])? ")";
	public BuiltinFunctionExpressionElements getBuiltinFunctionExpressionAccess() {
		return (pBuiltinFunctionExpression != null) ? pBuiltinFunctionExpression : (pBuiltinFunctionExpression = new BuiltinFunctionExpressionElements());
	}
	
	public ParserRule getBuiltinFunctionExpressionRule() {
		return getBuiltinFunctionExpressionAccess().getRule();
	}

	//enum BuiltinFunctions:
	//	isSet | alert | confirm | // copy an object									Note: used for Blaasfunctie.nl!
	//	copyOf | // convert a Date to milliseconds, for calculation
	//	toMillis | // rounds a Number to an Integer
	//	round | // sort a list
	//	sort | // validates some simple-typed lhs'es
	//	isValid | // retrieves the (internal, generated) id of a structure as String
	//	id;
	public BuiltinFunctionsElements getBuiltinFunctionsAccess() {
		return (unknownRuleBuiltinFunctions != null) ? unknownRuleBuiltinFunctions : (unknownRuleBuiltinFunctions = new BuiltinFunctionsElements());
	}
	
	public EnumRule getBuiltinFunctionsRule() {
		return getBuiltinFunctionsAccess().getRule();
	}

	//// TODO  consider adding a `bind` function which has the intent of making the value bound...
	/// *
	//	 * scoping: sortFeature in argument.type.features
	//	 * validation:
	//	 * 		1-  value.type.textuallyTyped if function is 'alert' or 'confirm'								[√]
	//	 * 		2-  argument.type.dateTyped if function is 'toMillis'											[√]
	//	 * 		3-  argument.type.numberTyped if function is 'round'											[√]
	//	 * 		4-	!value.type.structureTyped if function is 'isSet' (warning)									[√]
	//	 * 		5-  argument.type.emailTyped if function is 'isValid'											[√]
	//	 * 		6-  argument.type.listTyped && argument.type.listItemType.structureTyped if function is 'sort'	[ ]
	//	 * 		7-  sortFeature != null iff function is 'sort'													[√]
	//	 * 		8-  value.type.structureTyped if function is 'id'												[√]
	//	 * / // TODO  replace keyword-style expression(s) with implicitly imported functions
	//LiteralExpression:
	//	{StringLiteralExpression} value=STRING | {BooleanLiteralExpression} literal=BooleanLiterals |
	//	{IntegerLiteralExpression} value=INT | {NumberLiteralExpression} value=NumberLiteral | ListLiteralExpression |
	//	EnumerationLiteralExpression | DecisionExpression;
	public LiteralExpressionElements getLiteralExpressionAccess() {
		return (pLiteralExpression != null) ? pLiteralExpression : (pLiteralExpression = new LiteralExpressionElements());
	}
	
	public ParserRule getLiteralExpressionRule() {
		return getLiteralExpressionAccess().getRule();
	}

	//// TODO  add a literal expression for strings that require HTML escaping?
	//ListLiteralExpression:
	//	{ListLiteralExpression} "[" members+=Expression* "]";
	public ListLiteralExpressionElements getListLiteralExpressionAccess() {
		return (pListLiteralExpression != null) ? pListLiteralExpression : (pListLiteralExpression = new ListLiteralExpressionElements());
	}
	
	public ParserRule getListLiteralExpressionRule() {
		return getListLiteralExpressionAccess().getRule();
	}

	//// validation: members (if any) must be compatible with each other - for now this means that everything must be compatible with the first member	[√]
	//EnumerationLiteralExpression hidden():
	//	enumeration=[struct::Enumeration] "::" literal=[struct::EnumerationLiteral|EnumerationName];
	public EnumerationLiteralExpressionElements getEnumerationLiteralExpressionAccess() {
		return (pEnumerationLiteralExpression != null) ? pEnumerationLiteralExpression : (pEnumerationLiteralExpression = new EnumerationLiteralExpressionElements());
	}
	
	public ParserRule getEnumerationLiteralExpressionRule() {
		return getEnumerationLiteralExpressionAccess().getRule();
	}

	//// scoping: literal in enumeration.literals		[√]
	//// TODO  make enumeration optional if it can be derived from (lhs) context? (seems to easily cause non-LL(*) behavior...)
	//// (re-def. of INT)
	//terminal INT returns ecore::EInt:
	//	"-"? "0".."9"+;
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//// (datatype rule)
	//NumberLiteral returns ecore::EBigDecimal hidden():
	//	INT "." INT;
	public NumberLiteralElements getNumberLiteralAccess() {
		return (pNumberLiteral != null) ? pNumberLiteral : (pNumberLiteral = new NumberLiteralElements());
	}
	
	public ParserRule getNumberLiteralRule() {
		return getNumberLiteralAccess().getRule();
	}

	//// Note that the decimal part is required.
	//// TODO  fix problem with "negative" decimal part
	//enum BooleanLiterals:
	//	false / * default * / | true;
	public BooleanLiteralsElements getBooleanLiteralsAccess() {
		return (unknownRuleBooleanLiterals != null) ? unknownRuleBooleanLiterals : (unknownRuleBooleanLiterals = new BooleanLiteralsElements());
	}
	
	public EnumRule getBooleanLiteralsRule() {
		return getBooleanLiteralsAccess().getRule();
	}

	//DecisionExpression:
	//	{DecisionExpression} "decide" "{" cases+=DecisionCase* ("default" ":" defaultValueExpr=Expression)? "}";
	public DecisionExpressionElements getDecisionExpressionAccess() {
		return (pDecisionExpression != null) ? pDecisionExpression : (pDecisionExpression = new DecisionExpressionElements());
	}
	
	public ParserRule getDecisionExpressionRule() {
		return getDecisionExpressionAccess().getRule();
	}

	/// *
	//	 * type: cases.head.valueExpr.type or defaultValueExpr.type							[√]
	//	 * validation:
	//	 * 		1-  !cases.empty (warning)													[√]
	//	 * 		2-  type.isAssignableFrom(defaultValueExpr.type)							[√]
	//	 * / DecisionCase:
	//	"case" guardExpr=Expression ":" valueExpr=Expression;
	public DecisionCaseElements getDecisionCaseAccess() {
		return (pDecisionCase != null) ? pDecisionCase : (pDecisionCase = new DecisionCaseElements());
	}
	
	public ParserRule getDecisionCaseRule() {
		return getDecisionCaseAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 * 		1-  guardExpr.type.booleanTyped												[√]
	//	 * 		2-  containing(DecisionExpression).type.isAssignableFrom(guardExpr.type)	[√]
	//	 * / CallbackExpressions:
	//	CallbackExpression | {CallbackResponseExpression} // validation: only useable within callbacks	[√]
	//	"response" | {CallbackErrorResponseExpression} // validation: only useable within callbacks	[√]
	//	"error";
	public CallbackExpressionsElements getCallbackExpressionsAccess() {
		return (pCallbackExpressions != null) ? pCallbackExpressions : (pCallbackExpressions = new CallbackExpressionsElements());
	}
	
	public ParserRule getCallbackExpressionsRule() {
		return getCallbackExpressionsAccess().getRule();
	}

	//CallbackExpression:
	//	statementBlock=StatementBlock;
	public CallbackExpressionElements getCallbackExpressionAccess() {
		return (pCallbackExpression != null) ? pCallbackExpression : (pCallbackExpression = new CallbackExpressionElements());
	}
	
	public ParserRule getCallbackExpressionRule() {
		return getCallbackExpressionAccess().getRule();
	}

	//StructureCreationExpression:
	//	"new" structure=[struct::Structure] "(" assignments+=FeatureAssignment* ")";
	public StructureCreationExpressionElements getStructureCreationExpressionAccess() {
		return (pStructureCreationExpression != null) ? pStructureCreationExpression : (pStructureCreationExpression = new StructureCreationExpressionElements());
	}
	
	public ParserRule getStructureCreationExpressionRule() {
		return getStructureCreationExpressionAccess().getRule();
	}

	//// validation: features may not be duplicately assigned						[√]
	//FeatureAssignment:
	//	feature=[struct::Feature] "=" valueExpr=Expression;
	public FeatureAssignmentElements getFeatureAssignmentAccess() {
		return (pFeatureAssignment != null) ? pFeatureAssignment : (pFeatureAssignment = new FeatureAssignmentElements());
	}
	
	public ParserRule getFeatureAssignmentRule() {
		return getFeatureAssignmentAccess().getRule();
	}

	//// scoping: feature in containing(StructureCreationExpression).features		[√]
	//// validation: feature.type.isAssignableFrom(valueExpr.type)				[√]
	//ValueReferenceOrMethodCallExpression:
	//	ReferenceExpression ({MethodCallExpression.methodRef=current} => argumentList=ArgumentList)?;
	public ValueReferenceOrMethodCallExpressionElements getValueReferenceOrMethodCallExpressionAccess() {
		return (pValueReferenceOrMethodCallExpression != null) ? pValueReferenceOrMethodCallExpression : (pValueReferenceOrMethodCallExpression = new ValueReferenceOrMethodCallExpressionElements());
	}
	
	public ParserRule getValueReferenceOrMethodCallExpressionRule() {
		return getValueReferenceOrMethodCallExpressionAccess().getRule();
	}

	/// *
	//	 * validation (on MethodCallExpression):
	//	 * 		1-  methodRef.ref must be a Method										[√]
	//	 * 		2-  all parameters of methodRef.ref are covered and no more than once	[√]
	//	 * / // TODO  harden type calculation to deal with recursive call chains (+ validation?)
	//ReferenceExpression:
	//	ref=[Referable];
	public ReferenceExpressionElements getReferenceExpressionAccess() {
		return (pReferenceExpression != null) ? pReferenceExpression : (pReferenceExpression = new ReferenceExpressionElements());
	}
	
	public ParserRule getReferenceExpressionRule() {
		return getReferenceExpressionAccess().getRule();
	}

	//// validation: ref cannot be a method if eContainer is not a MethodCallExpression	[√]
	/// *
	// * TODO  consider adding a ValidID datatype rule and use that everywhere (including in cross-references: |ValidID)
	// * 			instead of ID to allow certain keywords (such as password, email and when) as valid identifiers.
	// * / // (synthetic type)
	/// *
	//	 * scoping: referables must come from local context
	//	 * 
	//	 * locality:
	//	 * 		- within ListElement: 			index-variables + (outer:) values + parameters + top-level methods	[√]
	//	 * 		- within DefinedViewable:		values + parameters + top-level methods								[√]
	//	 * 		- within Method(Definition):	parameters + top-level methods										[√]
	//	 * 		- within Statement:				preceding local values + scope from Method(Definition)				[√]		TODO  fix bug w.r.t. nested statement blocks? (not due to async block...)
	//	 * 		- within CallbackExpression:	preceding local values + scope from Element							[ ]		TODO  implement
	//	 * / Referable:
	//	Value | Parameter | ListVariable | Method;
	public ReferableElements getReferableAccess() {
		return (pReferable != null) ? pReferable : (pReferable = new ReferableElements());
	}
	
	public ParserRule getReferableRule() {
		return getReferableAccess().getRule();
	}

	//StructureModel:
	//	typeDefinitions+=DefinedType*;
	public SimStructureDslGrammarAccess.StructureModelElements getStructureModelAccess() {
		return gaSimStructureDsl.getStructureModelAccess();
	}
	
	public ParserRule getStructureModelRule() {
		return getStructureModelAccess().getRule();
	}

	//DefinedType:
	//	StructureDefinition | EnumerationDefinition;
	public SimStructureDslGrammarAccess.DefinedTypeElements getDefinedTypeAccess() {
		return gaSimStructureDsl.getDefinedTypeAccess();
	}
	
	public ParserRule getDefinedTypeRule() {
		return getDefinedTypeAccess().getRule();
	}

	//StructureDefinition returns Structure:
	//	"structure" name=ID persistent?="persistent"? "{" features+=Feature* "}";
	public SimStructureDslGrammarAccess.StructureDefinitionElements getStructureDefinitionAccess() {
		return gaSimStructureDsl.getStructureDefinitionAccess();
	}
	
	public ParserRule getStructureDefinitionRule() {
		return getStructureDefinitionAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 * 		1-  #features > 0														[√]
	//	 * 		2-  !persistent || structure-typed-features.forAll[type.persistent] 	[√]
	//	 * / / *
	//	 * semantics: corresponds to a JSON structure (+ all associated semantics, no references)
	//	 * 		as well as POJOs, controllers and CRUD servlets on the backend in case of the `persistent` marking
	//	 * / Feature:
	//	name=ID optional?="optional"? ":" type=TypeLiteral;
	public SimStructureDslGrammarAccess.FeatureElements getFeatureAccess() {
		return gaSimStructureDsl.getFeatureAccess();
	}
	
	public ParserRule getFeatureRule() {
		return getFeatureAccess().getRule();
	}

	//EnumerationDefinition returns Enumeration:
	//	"enumeration" name=ID "{" literals+=EnumerationLiteral* "}";
	public SimStructureDslGrammarAccess.EnumerationDefinitionElements getEnumerationDefinitionAccess() {
		return gaSimStructureDsl.getEnumerationDefinitionAccess();
	}
	
	public ParserRule getEnumerationDefinitionRule() {
		return getEnumerationDefinitionAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 * 		1-  #literals > 0					[√]
	//	 * 		2-  literals are uniquely-named		[ ]
	//	 * / EnumerationLiteral:
	//	name=EnumerationName "->" displayName=STRING;
	public SimStructureDslGrammarAccess.EnumerationLiteralElements getEnumerationLiteralAccess() {
		return gaSimStructureDsl.getEnumerationLiteralAccess();
	}
	
	public ParserRule getEnumerationLiteralRule() {
		return getEnumerationLiteralAccess().getRule();
	}

	//EnumerationName returns ecore::EString:
	//	ID | STRING | INT;
	public SimStructureDslGrammarAccess.EnumerationNameElements getEnumerationNameAccess() {
		return gaSimStructureDsl.getEnumerationNameAccess();
	}
	
	public ParserRule getEnumerationNameRule() {
		return getEnumerationNameAccess().getRule();
	}

	/// *
	// * +-------------+
	// * | type system |
	// * +-------------+
	// * / TypeLiteral:
	//	BuiltinTypeLiteral | DefinedTypeLiteral | ListTypeLiteral | SyntheticTypeLiteral;
	public SimStructureDslGrammarAccess.TypeLiteralElements getTypeLiteralAccess() {
		return gaSimStructureDsl.getTypeLiteralAccess();
	}
	
	public ParserRule getTypeLiteralRule() {
		return getTypeLiteralAccess().getRule();
	}

	//BuiltinTypeLiteral:
	//	builtin=BuiltinTypes;
	public SimStructureDslGrammarAccess.BuiltinTypeLiteralElements getBuiltinTypeLiteralAccess() {
		return gaSimStructureDsl.getBuiltinTypeLiteralAccess();
	}
	
	public ParserRule getBuiltinTypeLiteralRule() {
		return getBuiltinTypeLiteralAccess().getRule();
	}

	/// *
	// * Any changes made to this enum should be reflected in:
	// * - JavascriptGenerator.asEmptyJsMap
	// * - TestGenerator.getTestThingy and getTestEquals
	// * - SimpleTypeFactory and SimpleTypeConverter
	// * - JavaGeneratorHelper.asJavaTypeLiteral
	// * - SimStructureDslExtensions.isSimpleTyped
	// * - TypeSystemExtension.isPrimitiveTyped
	// * / enum BuiltinTypes:
	//	string="String" | boolean="Boolean" | integer="Integer" | url="URL" | text="Text" | number="Number" | email="Email" |
	//	phone="Phone" | date="Date" | password="Password";
	public SimStructureDslGrammarAccess.BuiltinTypesElements getBuiltinTypesAccess() {
		return gaSimStructureDsl.getBuiltinTypesAccess();
	}
	
	public EnumRule getBuiltinTypesRule() {
		return getBuiltinTypesAccess().getRule();
	}

	//// highlighting: just colored, not bold (=fugly)	[ ]
	//DefinedTypeLiteral:
	//	type=[DefinedType];
	public SimStructureDslGrammarAccess.DefinedTypeLiteralElements getDefinedTypeLiteralAccess() {
		return gaSimStructureDsl.getDefinedTypeLiteralAccess();
	}
	
	public ParserRule getDefinedTypeLiteralRule() {
		return getDefinedTypeLiteralAccess().getRule();
	}

	//// highlighting: render in italics					[ ]
	//ListTypeLiteral:
	//	"[" itemType=TypeLiteral "]";
	public SimStructureDslGrammarAccess.ListTypeLiteralElements getListTypeLiteralAccess() {
		return gaSimStructureDsl.getListTypeLiteralAccess();
	}
	
	public ParserRule getListTypeLiteralRule() {
		return getListTypeLiteralAccess().getRule();
	}

	//// validation: synthetic types can't be used in SimScript-Structure		[√]
	//// TODO  move expressions to here
	/// *
	// * Challenge: the expressions sub language refers to some concepts which are not intrinsic to the SimScript-Structure DSL,
	// * such as interfaces (or NamedService-s) from SimScript-Backend. It should be able to "inject" those things in SimScript-UI
	// * even though they are not defined in SimScript-Structure.
	// * / SyntheticTypeLiteral:
	//	{CallbackLiteral} // semantics: the (type literal of) a [ui::StatementBlock] in a `callback` feature
	//	"Callback" | {CallbackErrorResponseLiteral} // semantics: the (type literal of) the response returned when an interface (AJAX) call fails
	//	"Error" | {VoidLiteral} // semantics: the (type literal of) void type
	//	"$Void";
	public SimStructureDslGrammarAccess.SyntheticTypeLiteralElements getSyntheticTypeLiteralAccess() {
		return gaSimStructureDsl.getSyntheticTypeLiteralAccess();
	}
	
	public ParserRule getSyntheticTypeLiteralRule() {
		return getSyntheticTypeLiteralAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaSimStructureDsl.getIDRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaSimStructureDsl.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaSimStructureDsl.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaSimStructureDsl.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaSimStructureDsl.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaSimStructureDsl.getANY_OTHERRule();
	} 
}
