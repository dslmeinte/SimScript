/*
* generated by Xtext
*/
package nl.dslmeinte.simscript.structure.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class SimStructureDslGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class StructureModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StructureModel");
		private final Assignment cTypeDefinitionsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cTypeDefinitionsDefinedTypeParserRuleCall_0 = (RuleCall)cTypeDefinitionsAssignment.eContents().get(0);
		
		//StructureModel:
		//	typeDefinitions+=DefinedType*;
		public ParserRule getRule() { return rule; }

		//typeDefinitions+=DefinedType*
		public Assignment getTypeDefinitionsAssignment() { return cTypeDefinitionsAssignment; }

		//DefinedType
		public RuleCall getTypeDefinitionsDefinedTypeParserRuleCall_0() { return cTypeDefinitionsDefinedTypeParserRuleCall_0; }
	}

	public class DefinedTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DefinedType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStructureDefinitionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnumerationDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//DefinedType:
		//	StructureDefinition | EnumerationDefinition;
		public ParserRule getRule() { return rule; }

		//StructureDefinition | EnumerationDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//StructureDefinition
		public RuleCall getStructureDefinitionParserRuleCall_0() { return cStructureDefinitionParserRuleCall_0; }

		//EnumerationDefinition
		public RuleCall getEnumerationDefinitionParserRuleCall_1() { return cEnumerationDefinitionParserRuleCall_1; }
	}

	public class StructureDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StructureDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStructureKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cPersistentAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cPersistentPersistentKeyword_2_0 = (Keyword)cPersistentAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cFeaturesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFeaturesFeatureParserRuleCall_4_0 = (RuleCall)cFeaturesAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//StructureDefinition returns Structure:
		//	"structure" name=ID persistent?="persistent"? "{" features+=Feature* "}";
		public ParserRule getRule() { return rule; }

		//"structure" name=ID persistent?="persistent"? "{" features+=Feature* "}"
		public Group getGroup() { return cGroup; }

		//"structure"
		public Keyword getStructureKeyword_0() { return cStructureKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//persistent?="persistent"?
		public Assignment getPersistentAssignment_2() { return cPersistentAssignment_2; }

		//"persistent"
		public Keyword getPersistentPersistentKeyword_2_0() { return cPersistentPersistentKeyword_2_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//features+=Feature*
		public Assignment getFeaturesAssignment_4() { return cFeaturesAssignment_4; }

		//Feature
		public RuleCall getFeaturesFeatureParserRuleCall_4_0() { return cFeaturesFeatureParserRuleCall_4_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class FeatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Feature");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cOptionalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cOptionalOptionalKeyword_1_0 = (Keyword)cOptionalAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeTypeLiteralParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		/// *
		//	 * validation:
		//	 * 		1-  #features > 0														[√]
		//	 * 		2-  !persistent || structure-typed-features.forAll[type.persistent] 	[√]
		//	 * / / *
		//	 * semantics: corresponds to a JSON structure (+ all associated semantics, no references)
		//	 * 		as well as POJOs, controllers and CRUD servlets on the backend in case of the `persistent` marking
		//	 * / Feature:
		//	name=ID optional?="optional"? ":" type=TypeLiteral;
		public ParserRule getRule() { return rule; }

		//name=ID optional?="optional"? ":" type=TypeLiteral
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//optional?="optional"?
		public Assignment getOptionalAssignment_1() { return cOptionalAssignment_1; }

		//"optional"
		public Keyword getOptionalOptionalKeyword_1_0() { return cOptionalOptionalKeyword_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=TypeLiteral
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//TypeLiteral
		public RuleCall getTypeTypeLiteralParserRuleCall_3_0() { return cTypeTypeLiteralParserRuleCall_3_0; }
	}

	public class EnumerationDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumerationDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumerationKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cLiteralsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLiteralsEnumerationLiteralParserRuleCall_3_0 = (RuleCall)cLiteralsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//EnumerationDefinition returns Enumeration:
		//	"enumeration" name=ID "{" literals+=EnumerationLiteral* "}";
		public ParserRule getRule() { return rule; }

		//"enumeration" name=ID "{" literals+=EnumerationLiteral* "}"
		public Group getGroup() { return cGroup; }

		//"enumeration"
		public Keyword getEnumerationKeyword_0() { return cEnumerationKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//literals+=EnumerationLiteral*
		public Assignment getLiteralsAssignment_3() { return cLiteralsAssignment_3; }

		//EnumerationLiteral
		public RuleCall getLiteralsEnumerationLiteralParserRuleCall_3_0() { return cLiteralsEnumerationLiteralParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class EnumerationLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumerationLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameEnumerationNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDisplayNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDisplayNameSTRINGTerminalRuleCall_2_0 = (RuleCall)cDisplayNameAssignment_2.eContents().get(0);
		
		/// *
		//	 * validation:
		//	 * 		1-  #literals > 0					[√]
		//	 * 		2-  literals are uniquely-named		[ ]
		//	 * / EnumerationLiteral:
		//	name=EnumerationName "->" displayName=STRING;
		public ParserRule getRule() { return rule; }

		//name=EnumerationName "->" displayName=STRING
		public Group getGroup() { return cGroup; }

		//name=EnumerationName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//EnumerationName
		public RuleCall getNameEnumerationNameParserRuleCall_0_0() { return cNameEnumerationNameParserRuleCall_0_0; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }

		//displayName=STRING
		public Assignment getDisplayNameAssignment_2() { return cDisplayNameAssignment_2; }

		//STRING
		public RuleCall getDisplayNameSTRINGTerminalRuleCall_2_0() { return cDisplayNameSTRINGTerminalRuleCall_2_0; }
	}

	public class EnumerationNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumerationName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSTRINGTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//EnumerationName returns ecore::EString:
		//	ID | STRING | INT;
		public ParserRule getRule() { return rule; }

		//ID | STRING | INT
		public Alternatives getAlternatives() { return cAlternatives; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_1() { return cSTRINGTerminalRuleCall_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
	}

	public class TypeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBuiltinTypeLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDefinedTypeLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cListTypeLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSyntheticTypeLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		/// *
		// * +-------------+
		// * | type system |
		// * +-------------+
		// * / TypeLiteral:
		//	BuiltinTypeLiteral | DefinedTypeLiteral | ListTypeLiteral | SyntheticTypeLiteral;
		public ParserRule getRule() { return rule; }

		//BuiltinTypeLiteral | DefinedTypeLiteral | ListTypeLiteral | SyntheticTypeLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//BuiltinTypeLiteral
		public RuleCall getBuiltinTypeLiteralParserRuleCall_0() { return cBuiltinTypeLiteralParserRuleCall_0; }

		//DefinedTypeLiteral
		public RuleCall getDefinedTypeLiteralParserRuleCall_1() { return cDefinedTypeLiteralParserRuleCall_1; }

		//ListTypeLiteral
		public RuleCall getListTypeLiteralParserRuleCall_2() { return cListTypeLiteralParserRuleCall_2; }

		//SyntheticTypeLiteral
		public RuleCall getSyntheticTypeLiteralParserRuleCall_3() { return cSyntheticTypeLiteralParserRuleCall_3; }
	}

	public class BuiltinTypeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuiltinTypeLiteral");
		private final Assignment cBuiltinAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cBuiltinBuiltinTypesEnumRuleCall_0 = (RuleCall)cBuiltinAssignment.eContents().get(0);
		
		//BuiltinTypeLiteral:
		//	builtin=BuiltinTypes;
		public ParserRule getRule() { return rule; }

		//builtin=BuiltinTypes
		public Assignment getBuiltinAssignment() { return cBuiltinAssignment; }

		//BuiltinTypes
		public RuleCall getBuiltinBuiltinTypesEnumRuleCall_0() { return cBuiltinBuiltinTypesEnumRuleCall_0; }
	}

	public class DefinedTypeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DefinedTypeLiteral");
		private final Assignment cTypeAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cTypeDefinedTypeCrossReference_0 = (CrossReference)cTypeAssignment.eContents().get(0);
		private final RuleCall cTypeDefinedTypeIDTerminalRuleCall_0_1 = (RuleCall)cTypeDefinedTypeCrossReference_0.eContents().get(1);
		
		//// highlighting: just colored, not bold (=fugly)	[ ]
		//DefinedTypeLiteral:
		//	type=[DefinedType];
		public ParserRule getRule() { return rule; }

		//type=[DefinedType]
		public Assignment getTypeAssignment() { return cTypeAssignment; }

		//[DefinedType]
		public CrossReference getTypeDefinedTypeCrossReference_0() { return cTypeDefinedTypeCrossReference_0; }

		//ID
		public RuleCall getTypeDefinedTypeIDTerminalRuleCall_0_1() { return cTypeDefinedTypeIDTerminalRuleCall_0_1; }
	}

	public class ListTypeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ListTypeLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cItemTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cItemTypeTypeLiteralParserRuleCall_1_0 = (RuleCall)cItemTypeAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// highlighting: render in italics					[ ]
		//ListTypeLiteral:
		//	"[" itemType=TypeLiteral "]";
		public ParserRule getRule() { return rule; }

		//"[" itemType=TypeLiteral "]"
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//itemType=TypeLiteral
		public Assignment getItemTypeAssignment_1() { return cItemTypeAssignment_1; }

		//TypeLiteral
		public RuleCall getItemTypeTypeLiteralParserRuleCall_1_0() { return cItemTypeTypeLiteralParserRuleCall_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}

	public class SyntheticTypeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SyntheticTypeLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cCallbackLiteralAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cCallbackKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cCallbackErrorResponseLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cErrorKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cVoidLiteralAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cVoidKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		
		//// validation: synthetic types can't be used in SimScript-Structure		[√]
		//// TODO  move expressions to here
		/// *
		// * Challenge: the expressions sub language refers to some concepts which are not intrinsic to the SimScript-Structure DSL,
		// * such as interfaces (or NamedService-s) from SimScript-Backend. It should be able to "inject" those things in SimScript-UI
		// * even though they are not defined in SimScript-Structure.
		// * / SyntheticTypeLiteral:
		//	{CallbackLiteral} // semantics: the (type literal of) a [ui::StatementBlock] in a `callback` feature
		//	"Callback" | {CallbackErrorResponseLiteral} // semantics: the (type literal of) the response returned when an interface (AJAX) call fails
		//	"Error" | {VoidLiteral} // semantics: the (type literal of) void type
		//	"$Void";
		public ParserRule getRule() { return rule; }

		//{CallbackLiteral} // semantics: the (type literal of) a [ui::StatementBlock] in a `callback` feature
		//"Callback" | {CallbackErrorResponseLiteral} // semantics: the (type literal of) the response returned when an interface (AJAX) call fails
		//"Error" | {VoidLiteral} // semantics: the (type literal of) void type
		//"$Void"
		public Alternatives getAlternatives() { return cAlternatives; }

		//{CallbackLiteral} // semantics: the (type literal of) a [ui::StatementBlock] in a `callback` feature
		//"Callback"
		public Group getGroup_0() { return cGroup_0; }

		//{CallbackLiteral}
		public Action getCallbackLiteralAction_0_0() { return cCallbackLiteralAction_0_0; }

		//// semantics: the (type literal of) a [ui::StatementBlock] in a `callback` feature
		//"Callback"
		public Keyword getCallbackKeyword_0_1() { return cCallbackKeyword_0_1; }

		//{CallbackErrorResponseLiteral} // semantics: the (type literal of) the response returned when an interface (AJAX) call fails
		//"Error"
		public Group getGroup_1() { return cGroup_1; }

		//{CallbackErrorResponseLiteral}
		public Action getCallbackErrorResponseLiteralAction_1_0() { return cCallbackErrorResponseLiteralAction_1_0; }

		//// semantics: the (type literal of) the response returned when an interface (AJAX) call fails
		//"Error"
		public Keyword getErrorKeyword_1_1() { return cErrorKeyword_1_1; }

		//{VoidLiteral} // semantics: the (type literal of) void type
		//"$Void"
		public Group getGroup_2() { return cGroup_2; }

		//{VoidLiteral}
		public Action getVoidLiteralAction_2_0() { return cVoidLiteralAction_2_0; }

		//// semantics: the (type literal of) void type
		//"$Void"
		public Keyword getVoidKeyword_2_1() { return cVoidKeyword_2_1; }
	}
	
	
	public class BuiltinTypesElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "BuiltinTypes");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cStringEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cStringStringKeyword_0_0 = (Keyword)cStringEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cBooleanEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cBooleanBooleanKeyword_1_0 = (Keyword)cBooleanEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cIntegerEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cIntegerIntegerKeyword_2_0 = (Keyword)cIntegerEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cUrlEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cUrlURLKeyword_3_0 = (Keyword)cUrlEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cTextEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cTextTextKeyword_4_0 = (Keyword)cTextEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cNumberEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cNumberNumberKeyword_5_0 = (Keyword)cNumberEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cEmailEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cEmailEmailKeyword_6_0 = (Keyword)cEmailEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cPhoneEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cPhonePhoneKeyword_7_0 = (Keyword)cPhoneEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cDateEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cDateDateKeyword_8_0 = (Keyword)cDateEnumLiteralDeclaration_8.eContents().get(0);
		private final EnumLiteralDeclaration cPasswordEnumLiteralDeclaration_9 = (EnumLiteralDeclaration)cAlternatives.eContents().get(9);
		private final Keyword cPasswordPasswordKeyword_9_0 = (Keyword)cPasswordEnumLiteralDeclaration_9.eContents().get(0);
		
		/// *
		// * Any changes made to this enum should be reflected in:
		// * - JavascriptGenerator.asEmptyJsMap
		// * - TestGenerator.getTestThingy and getTestEquals
		// * - SimpleTypeFactory and SimpleTypeConverter
		// * - JavaGeneratorHelper.asJavaTypeLiteral
		// * - SimStructureDslExtensions.isSimpleTyped
		// * - TypeSystemExtension.isPrimitiveTyped
		// * / enum BuiltinTypes:
		//	string="String" | boolean="Boolean" | integer="Integer" | url="URL" | text="Text" | number="Number" | email="Email" |
		//	phone="Phone" | date="Date" | password="Password";
		public EnumRule getRule() { return rule; }

		//string="String" | boolean="Boolean" | integer="Integer" | url="URL" | text="Text" | number="Number" | email="Email" |
		//phone="Phone" | date="Date" | password="Password"
		public Alternatives getAlternatives() { return cAlternatives; }

		//string="String"
		public EnumLiteralDeclaration getStringEnumLiteralDeclaration_0() { return cStringEnumLiteralDeclaration_0; }

		//"String"
		public Keyword getStringStringKeyword_0_0() { return cStringStringKeyword_0_0; }

		//boolean="Boolean"
		public EnumLiteralDeclaration getBooleanEnumLiteralDeclaration_1() { return cBooleanEnumLiteralDeclaration_1; }

		//"Boolean"
		public Keyword getBooleanBooleanKeyword_1_0() { return cBooleanBooleanKeyword_1_0; }

		//integer="Integer"
		public EnumLiteralDeclaration getIntegerEnumLiteralDeclaration_2() { return cIntegerEnumLiteralDeclaration_2; }

		//"Integer"
		public Keyword getIntegerIntegerKeyword_2_0() { return cIntegerIntegerKeyword_2_0; }

		//url="URL"
		public EnumLiteralDeclaration getUrlEnumLiteralDeclaration_3() { return cUrlEnumLiteralDeclaration_3; }

		//"URL"
		public Keyword getUrlURLKeyword_3_0() { return cUrlURLKeyword_3_0; }

		//text="Text"
		public EnumLiteralDeclaration getTextEnumLiteralDeclaration_4() { return cTextEnumLiteralDeclaration_4; }

		//"Text"
		public Keyword getTextTextKeyword_4_0() { return cTextTextKeyword_4_0; }

		//number="Number"
		public EnumLiteralDeclaration getNumberEnumLiteralDeclaration_5() { return cNumberEnumLiteralDeclaration_5; }

		//"Number"
		public Keyword getNumberNumberKeyword_5_0() { return cNumberNumberKeyword_5_0; }

		//email="Email"
		public EnumLiteralDeclaration getEmailEnumLiteralDeclaration_6() { return cEmailEnumLiteralDeclaration_6; }

		//"Email"
		public Keyword getEmailEmailKeyword_6_0() { return cEmailEmailKeyword_6_0; }

		//phone="Phone"
		public EnumLiteralDeclaration getPhoneEnumLiteralDeclaration_7() { return cPhoneEnumLiteralDeclaration_7; }

		//"Phone"
		public Keyword getPhonePhoneKeyword_7_0() { return cPhonePhoneKeyword_7_0; }

		//date="Date"
		public EnumLiteralDeclaration getDateEnumLiteralDeclaration_8() { return cDateEnumLiteralDeclaration_8; }

		//"Date"
		public Keyword getDateDateKeyword_8_0() { return cDateDateKeyword_8_0; }

		//password="Password"
		public EnumLiteralDeclaration getPasswordEnumLiteralDeclaration_9() { return cPasswordEnumLiteralDeclaration_9; }

		//"Password"
		public Keyword getPasswordPasswordKeyword_9_0() { return cPasswordPasswordKeyword_9_0; }
	}
	
	private StructureModelElements pStructureModel;
	private DefinedTypeElements pDefinedType;
	private StructureDefinitionElements pStructureDefinition;
	private FeatureElements pFeature;
	private EnumerationDefinitionElements pEnumerationDefinition;
	private EnumerationLiteralElements pEnumerationLiteral;
	private EnumerationNameElements pEnumerationName;
	private TypeLiteralElements pTypeLiteral;
	private BuiltinTypeLiteralElements pBuiltinTypeLiteral;
	private BuiltinTypesElements unknownRuleBuiltinTypes;
	private DefinedTypeLiteralElements pDefinedTypeLiteral;
	private ListTypeLiteralElements pListTypeLiteral;
	private SyntheticTypeLiteralElements pSyntheticTypeLiteral;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public SimStructureDslGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("nl.dslmeinte.simscript.structure.SimStructureDsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//StructureModel:
	//	typeDefinitions+=DefinedType*;
	public StructureModelElements getStructureModelAccess() {
		return (pStructureModel != null) ? pStructureModel : (pStructureModel = new StructureModelElements());
	}
	
	public ParserRule getStructureModelRule() {
		return getStructureModelAccess().getRule();
	}

	//DefinedType:
	//	StructureDefinition | EnumerationDefinition;
	public DefinedTypeElements getDefinedTypeAccess() {
		return (pDefinedType != null) ? pDefinedType : (pDefinedType = new DefinedTypeElements());
	}
	
	public ParserRule getDefinedTypeRule() {
		return getDefinedTypeAccess().getRule();
	}

	//StructureDefinition returns Structure:
	//	"structure" name=ID persistent?="persistent"? "{" features+=Feature* "}";
	public StructureDefinitionElements getStructureDefinitionAccess() {
		return (pStructureDefinition != null) ? pStructureDefinition : (pStructureDefinition = new StructureDefinitionElements());
	}
	
	public ParserRule getStructureDefinitionRule() {
		return getStructureDefinitionAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 * 		1-  #features > 0														[√]
	//	 * 		2-  !persistent || structure-typed-features.forAll[type.persistent] 	[√]
	//	 * / / *
	//	 * semantics: corresponds to a JSON structure (+ all associated semantics, no references)
	//	 * 		as well as POJOs, controllers and CRUD servlets on the backend in case of the `persistent` marking
	//	 * / Feature:
	//	name=ID optional?="optional"? ":" type=TypeLiteral;
	public FeatureElements getFeatureAccess() {
		return (pFeature != null) ? pFeature : (pFeature = new FeatureElements());
	}
	
	public ParserRule getFeatureRule() {
		return getFeatureAccess().getRule();
	}

	//EnumerationDefinition returns Enumeration:
	//	"enumeration" name=ID "{" literals+=EnumerationLiteral* "}";
	public EnumerationDefinitionElements getEnumerationDefinitionAccess() {
		return (pEnumerationDefinition != null) ? pEnumerationDefinition : (pEnumerationDefinition = new EnumerationDefinitionElements());
	}
	
	public ParserRule getEnumerationDefinitionRule() {
		return getEnumerationDefinitionAccess().getRule();
	}

	/// *
	//	 * validation:
	//	 * 		1-  #literals > 0					[√]
	//	 * 		2-  literals are uniquely-named		[ ]
	//	 * / EnumerationLiteral:
	//	name=EnumerationName "->" displayName=STRING;
	public EnumerationLiteralElements getEnumerationLiteralAccess() {
		return (pEnumerationLiteral != null) ? pEnumerationLiteral : (pEnumerationLiteral = new EnumerationLiteralElements());
	}
	
	public ParserRule getEnumerationLiteralRule() {
		return getEnumerationLiteralAccess().getRule();
	}

	//EnumerationName returns ecore::EString:
	//	ID | STRING | INT;
	public EnumerationNameElements getEnumerationNameAccess() {
		return (pEnumerationName != null) ? pEnumerationName : (pEnumerationName = new EnumerationNameElements());
	}
	
	public ParserRule getEnumerationNameRule() {
		return getEnumerationNameAccess().getRule();
	}

	/// *
	// * +-------------+
	// * | type system |
	// * +-------------+
	// * / TypeLiteral:
	//	BuiltinTypeLiteral | DefinedTypeLiteral | ListTypeLiteral | SyntheticTypeLiteral;
	public TypeLiteralElements getTypeLiteralAccess() {
		return (pTypeLiteral != null) ? pTypeLiteral : (pTypeLiteral = new TypeLiteralElements());
	}
	
	public ParserRule getTypeLiteralRule() {
		return getTypeLiteralAccess().getRule();
	}

	//BuiltinTypeLiteral:
	//	builtin=BuiltinTypes;
	public BuiltinTypeLiteralElements getBuiltinTypeLiteralAccess() {
		return (pBuiltinTypeLiteral != null) ? pBuiltinTypeLiteral : (pBuiltinTypeLiteral = new BuiltinTypeLiteralElements());
	}
	
	public ParserRule getBuiltinTypeLiteralRule() {
		return getBuiltinTypeLiteralAccess().getRule();
	}

	/// *
	// * Any changes made to this enum should be reflected in:
	// * - JavascriptGenerator.asEmptyJsMap
	// * - TestGenerator.getTestThingy and getTestEquals
	// * - SimpleTypeFactory and SimpleTypeConverter
	// * - JavaGeneratorHelper.asJavaTypeLiteral
	// * - SimStructureDslExtensions.isSimpleTyped
	// * - TypeSystemExtension.isPrimitiveTyped
	// * / enum BuiltinTypes:
	//	string="String" | boolean="Boolean" | integer="Integer" | url="URL" | text="Text" | number="Number" | email="Email" |
	//	phone="Phone" | date="Date" | password="Password";
	public BuiltinTypesElements getBuiltinTypesAccess() {
		return (unknownRuleBuiltinTypes != null) ? unknownRuleBuiltinTypes : (unknownRuleBuiltinTypes = new BuiltinTypesElements());
	}
	
	public EnumRule getBuiltinTypesRule() {
		return getBuiltinTypesAccess().getRule();
	}

	//// highlighting: just colored, not bold (=fugly)	[ ]
	//DefinedTypeLiteral:
	//	type=[DefinedType];
	public DefinedTypeLiteralElements getDefinedTypeLiteralAccess() {
		return (pDefinedTypeLiteral != null) ? pDefinedTypeLiteral : (pDefinedTypeLiteral = new DefinedTypeLiteralElements());
	}
	
	public ParserRule getDefinedTypeLiteralRule() {
		return getDefinedTypeLiteralAccess().getRule();
	}

	//// highlighting: render in italics					[ ]
	//ListTypeLiteral:
	//	"[" itemType=TypeLiteral "]";
	public ListTypeLiteralElements getListTypeLiteralAccess() {
		return (pListTypeLiteral != null) ? pListTypeLiteral : (pListTypeLiteral = new ListTypeLiteralElements());
	}
	
	public ParserRule getListTypeLiteralRule() {
		return getListTypeLiteralAccess().getRule();
	}

	//// validation: synthetic types can't be used in SimScript-Structure		[√]
	//// TODO  move expressions to here
	/// *
	// * Challenge: the expressions sub language refers to some concepts which are not intrinsic to the SimScript-Structure DSL,
	// * such as interfaces (or NamedService-s) from SimScript-Backend. It should be able to "inject" those things in SimScript-UI
	// * even though they are not defined in SimScript-Structure.
	// * / SyntheticTypeLiteral:
	//	{CallbackLiteral} // semantics: the (type literal of) a [ui::StatementBlock] in a `callback` feature
	//	"Callback" | {CallbackErrorResponseLiteral} // semantics: the (type literal of) the response returned when an interface (AJAX) call fails
	//	"Error" | {VoidLiteral} // semantics: the (type literal of) void type
	//	"$Void";
	public SyntheticTypeLiteralElements getSyntheticTypeLiteralAccess() {
		return (pSyntheticTypeLiteral != null) ? pSyntheticTypeLiteral : (pSyntheticTypeLiteral = new SyntheticTypeLiteralElements());
	}
	
	public ParserRule getSyntheticTypeLiteralRule() {
		return getSyntheticTypeLiteralAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
